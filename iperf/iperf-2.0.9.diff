diff -uprN iperf-2.0.9.orig/compat/Thread.c iperf-2.0.9/compat/Thread.c
--- iperf-2.0.9.orig/compat/Thread.c	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/compat/Thread.c	2017-02-11 02:06:37.178429035 +0900
@@ -78,6 +78,12 @@
 extern "C" {
 #endif
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /* -------------------------------------------------------------------
  * define static variables.
  * ------------------------------------------------------------------- */
@@ -187,7 +193,11 @@ void thread_stop( struct thread_Settings
         if ( thread_equalid( thread_getid(), thread->mTID ) ) {
 
             // Destroy the object
-            Settings_Destroy( thread );
+            if (thread != NULL) {
+                DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, thread);
+                Settings_Destroy( thread );
+                thread = NULL;
+            }
 
             // Exit
 #if   defined( HAVE_POSIX_THREAD )
@@ -211,7 +221,11 @@ void thread_stop( struct thread_Settings
 #endif
 
             // Destroy the object only after killing the thread
-            Settings_Destroy( thread );
+            if (thread != NULL) {
+                DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, thread);
+                Settings_Destroy( thread );
+                thread = NULL;
+            }
         }
     }
 #endif
@@ -280,7 +294,11 @@ thread_run_wrapper( void* paramPtr ) {
     }
 
     // Destroy this thread object
-    Settings_Destroy( thread );
+    if (thread != NULL) {
+        DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, thread);
+        Settings_Destroy( thread );
+        thread = NULL;
+    }
 
     return 0;
 } // end run_wrapper
diff -uprN iperf-2.0.9.orig/include/Locale.h iperf-2.0.9/include/Locale.h
--- iperf-2.0.9.orig/include/Locale.h	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/include/Locale.h	2017-02-11 02:06:37.182429055 +0900
@@ -120,6 +120,8 @@ extern const char report_bw_jitter_loss_
 
 extern const char report_sum_bw_jitter_loss_format[];
 
+extern const char reportCSV_bw_cpu[];
+
 /* -------------------------------------------------------------------
  * Enhanced reports (per -e)
  * ------------------------------------------------------------------- */
diff -uprN iperf-2.0.9.orig/include/Reporter.h iperf-2.0.9/include/Reporter.h
--- iperf-2.0.9.orig/include/Reporter.h	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/include/Reporter.h	2017-02-11 02:06:37.182429055 +0900
@@ -170,6 +170,9 @@ typedef struct Transfer_Info {
     char   mUDP;
     char   mTCP;
     char   free;
+
+    uint32_t pcpu[4];
+
 } Transfer_Info;
 
 typedef struct Connection_Info {
diff -uprN iperf-2.0.9.orig/include/Settings.hpp iperf-2.0.9/include/Settings.hpp
--- iperf-2.0.9.orig/include/Settings.hpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/include/Settings.hpp	2017-02-11 02:06:37.182429055 +0900
@@ -156,7 +156,7 @@ typedef struct thread_Settings {
         bool   mNoServerReport;         // -x 
         bool   mNoMultReport;           // -x m
         bool   mSinlgeClient;           // -1 */
-    int flags; 
+    unsigned int flags; 
     // enums (which should be special int's)
     ThreadMode mThreadMode;         // -s or -c
     ReportMode mReportMode;
@@ -173,7 +173,7 @@ typedef struct thread_Settings {
     unsigned short mBindPort;      // -B 
     // chars
     char   mFormat;                 // -f
-    int mTTL;                    // -T
+    unsigned int mTTL;                    // -T
     char pad1[2];
     // structs or miscellaneous
     iperf_sockaddr peer;
@@ -185,6 +185,13 @@ typedef struct thread_Settings {
 #if defined( HAVE_WIN32_THREAD )
     HANDLE mHandle;
 #endif
+
+    int mAffinity;
+    int mAffinityEnd;
+    int mAffinityComma;
+
+    uint32_t pcpu[4];
+
 } thread_Settings;
 
 /*
@@ -321,11 +328,11 @@ typedef struct thread_Settings {
 // use int32_t if possible, otherwise a 32 bit bitfield (e.g. on J90) 
 typedef struct UDP_datagram {
 #ifdef HAVE_INT32_T
-    int32_t id;
+    uint32_t id;
     u_int32_t tv_sec;
     u_int32_t tv_usec;
 #else
-    signed   int id      : 32;
+    unsigned int id      : 32;
     unsigned int tv_sec  : 32;
     unsigned int tv_usec : 32;
 #endif
@@ -354,25 +361,25 @@ typedef struct client_hdr {
      * tradeoff modes, wheither the speaker needs to start 
      * immediately or after the audience finishes.
      */
-    int32_t flags;
-    int32_t numThreads;
-    int32_t mPort;
-    int32_t bufferlen;
-    int32_t mWindowSize;
-    int32_t mAmount;
-    int32_t mRate;
-    int32_t mUDPRateUnits;
-    int32_t mRealtime;
+    uint32_t flags;
+    uint32_t numThreads;
+    uint32_t mPort;
+    uint32_t bufferlen;
+    uint32_t mWindowSize;
+    uint32_t mAmount;
+    uint32_t mRate;
+    uint32_t mUDPRateUnits;
+    uint32_t mRealtime;
 #else
-    signed int flags      : 32;
-    signed int numThreads : 32;
-    signed int mPort      : 32;
-    signed int bufferlen  : 32;
-    signed int mWindowSize : 32;
-    signed int mAmount    : 32;
-    signed int mRate      : 32;
-    signed int mUDPRateUnits : 32;
-    signed int mRealtime  : 32;
+    unsigned int flags      : 32;
+    unsigned int numThreads : 32;
+    unsigned int mPort      : 32;
+    unsigned int bufferlen  : 32;
+    unsigned int mWindowSize : 32;
+    unsigned int mAmount    : 32;
+    unsigned int mRate      : 32;
+    unsigned int mUDPRateUnits : 32;
+    unsigned int mRealtime  : 32;
 #endif
 } client_hdr;
 
@@ -395,57 +402,62 @@ typedef struct server_hdr {
      * set signifying additional information. If no 
      * information bits are set then the header is ignored.
      */
-    int32_t flags;
-    int32_t total_len1;
-    int32_t total_len2;
-    int32_t stop_sec;
-    int32_t stop_usec;
-    int32_t error_cnt;
-    int32_t outorder_cnt;
-    int32_t datagrams;
-    int32_t jitter1;
-    int32_t jitter2;
-    int32_t minTransit1;
-    int32_t minTransit2;
-    int32_t maxTransit1;
-    int32_t maxTransit2;
-    int32_t sumTransit1;
-    int32_t sumTransit2;
-    int32_t meanTransit1;
-    int32_t meanTransit2;
-    int32_t m2Transit1;
-    int32_t m2Transit2;
-    int32_t vdTransit1;
-    int32_t vdTransit2;
-    int32_t cntTransit;
-    int32_t IPGcnt;
-    int32_t IPGsum;
+    uint32_t flags;
+    uint32_t total_len1;
+    uint32_t total_len2;
+    uint32_t stop_sec;
+    uint32_t stop_usec;
+    uint32_t error_cnt;
+    uint32_t outorder_cnt;
+    uint32_t datagrams;
+    uint32_t jitter1;
+    uint32_t jitter2;
+    uint32_t minTransit1;
+    uint32_t minTransit2;
+    uint32_t maxTransit1;
+    uint32_t maxTransit2;
+    uint32_t sumTransit1;
+    uint32_t sumTransit2;
+    uint32_t meanTransit1;
+    uint32_t meanTransit2;
+    uint32_t m2Transit1;
+    uint32_t m2Transit2;
+    uint32_t vdTransit1;
+    uint32_t vdTransit2;
+    uint32_t cntTransit;
+    uint32_t IPGcnt;
+    uint32_t IPGsum;
+
+    uint32_t pcpu[4];
 #else
-    signed int flags        : 32;
-    signed int total_len1   : 32;
-    signed int total_len2   : 32;
-    signed int stop_sec     : 32;
-    signed int stop_usec    : 32;
-    signed int error_cnt    : 32;
-    signed int outorder_cnt : 32;
-    signed int datagrams    : 32;
-    signed int jitter1      : 32;
-    signed int jitter2      : 32;
-    signed int minTransit1  : 32;
-    signed int minTransit2  : 32;
-    signed int maxTransit1  : 32;
-    signed int maxTransit2  : 32;
-    signed int sumTransit1  : 32;
-    signed int sumTransit2  : 32;
-    signed int meanTransit1  : 32;
-    signed int meanTransit2  : 32;
-    signed int m2Transit1  : 32;
-    signed int m2Transit2  : 32;
-    signed int vdTransit1  : 32;
-    signed int vdTransit2  : 32;
-    signed int cntTransit   : 32;
-    signed int IPGcnt       : 32;
-    signed int IPGsum       : 32;
+    unsigned int flags        : 32;
+    unsigned int total_len1   : 32;
+    unsigned int total_len2   : 32;
+    unsigned int stop_sec     : 32;
+    unsigned int stop_usec    : 32;
+    unsigned int error_cnt    : 32;
+    unsigned int outorder_cnt : 32;
+    unsigned int datagrams    : 32;
+    unsigned int jitter1      : 32;
+    unsigned int jitter2      : 32;
+    unsigned int minTransit1  : 32;
+    unsigned int minTransit2  : 32;
+    unsigned int maxTransit1  : 32;
+    unsigned int maxTransit2  : 32;
+    unsigned int sumTransit1  : 32;
+    unsigned int sumTransit2  : 32;
+    unsigned int meanTransit1  : 32;
+    unsigned int meanTransit2  : 32;
+    unsigned int m2Transit1  : 32;
+    unsigned int m2Transit2  : 32;
+    unsigned int vdTransit1  : 32;
+    unsigned int vdTransit2  : 32;
+    unsigned int cntTransit   : 32;
+    unsigned int IPGcnt       : 32;
+    unsigned int IPGsum       : 32;
+
+    unsigned int pcpu[4];
+
 #endif
 
 } server_hdr;
diff -uprN iperf-2.0.9.orig/src/Client.cpp iperf-2.0.9/src/Client.cpp
--- iperf-2.0.9.orig/src/Client.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Client.cpp	2017-02-13 07:45:10.709628788 +0900
@@ -68,6 +68,12 @@
 #include <sys/mman.h>
 #endif
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /* -------------------------------------------------------------------
  * Store server hostname, optionally local hostname, and socket info.
  * ------------------------------------------------------------------- */
@@ -78,6 +84,8 @@ Client::Client( thread_Settings *inSetti
 
     // initialize buffer
     mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
+
     pattern( mBuf, mSettings->mBufLen );
     if ( isFileInput( mSettings ) ) {
         if ( !isSTDIN( mSettings ) )
@@ -103,7 +111,6 @@ Client::Client( thread_Settings *inSetti
             mSettings->multihdr->report->connection.size_local = mSettings->size_local;
         }
     }
-
 } // end Client
 
 /* -------------------------------------------------------------------
@@ -112,11 +119,17 @@ Client::Client( thread_Settings *inSetti
 
 Client::~Client() {
     if ( mSettings->mSock != INVALID_SOCKET ) {
+        DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
         int rc = close( mSettings->mSock );
         WARN_errno( rc == SOCKET_ERROR, "close" );
         mSettings->mSock = INVALID_SOCKET;
     }
-    DELETE_ARRAY( mBuf );
+
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+    }
 } // end ~Client
 
 // const double kSecs_to_usecs = 1e6; 
@@ -154,6 +167,7 @@ void Client::RunRateLimitedTCP ( void )
     // InitReport handles Barrier for multiple Streams
     mSettings->reporthdr = InitReport( mSettings );
     reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
     reportstruct->packetID = 0;
     reportstruct->emptyreport=0;
     reportstruct->socket = mSettings->mSock;
@@ -295,6 +309,8 @@ void Client::RunTCP( void ) {
     // InitReport handles Barrier for multiple Streams
     mSettings->reporthdr = InitReport( mSettings );
     reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+
     reportstruct->packetID = 0;
     reportstruct->emptyreport=0;
     reportstruct->socket = mSettings->mSock;
@@ -403,7 +419,12 @@ void Client::RunTCP( void ) {
     }
     CloseReport( mSettings->reporthdr, reportstruct );
 
-    DELETE_PTR( reportstruct );
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
+
     EndReport( mSettings->reporthdr );
 }
 
@@ -525,6 +546,7 @@ void Client::Run( void ) {
     // InitReport handles Barrier for multiple Streams
     mSettings->reporthdr = InitReport( mSettings );
     reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
     reportstruct->packetID = 0;
     reportstruct->emptyreport=0;
     reportstruct->errwrite=0;
@@ -658,12 +680,23 @@ void Client::Run( void ) {
         mBuf_UDP->tv_usec = htonl( reportstruct->packetTime.tv_usec ); 
 
         if ( isMulticast( mSettings ) ) {
-            write( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+            ssize_t ret = write( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+            if (ret < 0) {
+                DEBUGP("%s[%d]: write error!! ret=%zd(%d)", __FILE__, (int)__LINE__, ret, errno);
+            }
+
         } else {
-            write_UDP_FIN( ); 
+          write_UDP_FIN( ); 
         }
     }
-    DELETE_PTR( reportstruct );
+    //write_UDP_FIN( );
+
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
+
     EndReport( mSettings->reporthdr );
 } 
 // end Run
@@ -671,7 +704,7 @@ void Client::Run( void ) {
 void Client::InitiateServer() {
     if ( !isCompat( mSettings ) ) {
         int currLen;
-        client_hdr* temp_hdr;
+        client_hdr* temp_hdr = NULL;
         if ( isUDP( mSettings ) ) {
             UDP_datagram *UDPhdr = (UDP_datagram *)mBuf;
             temp_hdr = (client_hdr*)(UDPhdr + 1);
@@ -741,18 +774,24 @@ void Client::Connect( ) {
  * ------------------------------------------------------------------- */ 
 
 void Client::write_UDP_FIN( ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     int rc; 
     fd_set readSet; 
     struct timeval timeout; 
-    struct UDP_datagram* mBuf_UDP = (struct UDP_datagram*) mBuf; 
+    struct UDP_datagram* mBuf_UDP = (struct UDP_datagram*) mBuf;
+    ssize_t ret = 0;
 
     int count = 0; 
     int packetid;
+    //sleep(1);
     while ( count < 10 ) {
         count++; 
 
-        // write data 
-        write( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+        // write data  
+        ret = write( mSettings->mSock, mBuf, mSettings->mBufLen );
+        if (ret < 0) {
+            printf("%s[%d]: write error!! ret=%zd(%d)\n", __FILE__, (int)__LINE__, ret, errno);
+        }
 	// decrement the packet count
 	packetid = ntohl(mBuf_UDP->id);
         mBuf_UDP->id = htonl(--packetid); 
@@ -768,15 +807,21 @@ void Client::write_UDP_FIN( ) {
 
         if ( rc == 0 ) {
             // select timed out 
+            printf("%s[%d]: select timeout!! rc=%d(%d)\n", __FILE__, (int)__LINE__, rc, errno);
             continue; 
         } else {
+            int len = sizeof(UDP_datagram) + sizeof(server_hdr);
+            char buf[300];
+            memset(buf, 0x00, sizeof(buf));
+            UDP_datagram* udp = (UDP_datagram*)buf;
             // socket ready to read 
-            rc = read( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+            rc = read( mSettings->mSock, buf, len ); 
             WARN_errno( rc < 0, "read" );
     	    if ( rc < 0 ) {
+                printf("%s[%d]: read error!! rc=%d(%d)\n", __FILE__, (int)__LINE__, rc, errno);
                 break;
-            } else if ( rc >= (int) (sizeof(UDP_datagram) + sizeof(server_hdr)) ) {
-                ReportServerUDP( mSettings, (server_hdr*) ((UDP_datagram*)mBuf + 1) );
+            } else {
+                ReportServerUDP( mSettings, (server_hdr*) ((UDP_datagram*)udp + 1) );
             }
 
             return; 
diff -uprN iperf-2.0.9.orig/src/Client.cpp.~1~ iperf-2.0.9/src/Client.cpp.~1~
--- iperf-2.0.9.orig/src/Client.cpp.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Client.cpp.~1~	2017-02-11 02:06:37.186429074 +0900
@@ -0,0 +1,828 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Client.cpp
+ * by Mark Gates <mgates@nlanr.net>
+ * -------------------------------------------------------------------
+ * A client thread initiates a connect to the server and handles
+ * sending and receiving data, then closes the socket.
+ * ------------------------------------------------------------------- */
+
+#include <time.h>
+#include "headers.h"
+#include "Client.hpp"
+#include "Thread.h"
+#include "SocketAddr.h"
+#include "PerfSocket.hpp"
+#include "Extractor.h"
+#include "delay.h"
+#include "util.h"
+#include "Locale.h"
+#ifdef HAVE_SCHED_SETSCHEDULER
+#include <sched.h>
+#endif
+#ifdef HAVE_MLOCKALL
+#include <sys/mman.h>
+#endif
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+/* -------------------------------------------------------------------
+ * Store server hostname, optionally local hostname, and socket info.
+ * ------------------------------------------------------------------- */
+
+Client::Client( thread_Settings *inSettings ) {
+    mSettings = inSettings;
+    mBuf = NULL;
+
+    // initialize buffer
+    mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
+
+    pattern( mBuf, mSettings->mBufLen );
+    if ( isFileInput( mSettings ) ) {
+        if ( !isSTDIN( mSettings ) )
+            Extractor_Initialize( mSettings->mFileName, mSettings->mBufLen, mSettings );
+        else
+            Extractor_InitializeFile( stdin, mSettings->mBufLen, mSettings );
+
+        if ( !Extractor_canRead( mSettings ) ) {
+            unsetFileInput( mSettings );
+        }
+    }
+
+    // connect
+    Connect( );
+
+    if ( isReport( inSettings ) ) {
+        ReportSettings( inSettings );
+        if ( mSettings->multihdr && isMultipleReport( inSettings ) ) {
+            mSettings->multihdr->report->connection.peer = mSettings->peer;
+            mSettings->multihdr->report->connection.size_peer = mSettings->size_peer;
+            mSettings->multihdr->report->connection.local = mSettings->local;
+            SockAddr_setPortAny( &mSettings->multihdr->report->connection.local );
+            mSettings->multihdr->report->connection.size_local = mSettings->size_local;
+        }
+    }
+} // end Client
+
+/* -------------------------------------------------------------------
+ * Delete memory (hostname strings).
+ * ------------------------------------------------------------------- */
+
+Client::~Client() {
+    if ( mSettings->mSock != INVALID_SOCKET ) {
+        int rc = close( mSettings->mSock );
+        WARN_errno( rc == SOCKET_ERROR, "close" );
+        mSettings->mSock = INVALID_SOCKET;
+    }
+
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+    }
+} // end ~Client
+
+// const double kSecs_to_usecs = 1e6; 
+const double kSecs_to_nsecs = 1e9; 
+const int    kBytes_to_Bits = 8; 
+
+// A version of the transmit loop that
+// supports TCP rate limiting using a token bucket
+void Client::RunRateLimitedTCP ( void ) {
+    int currLen = 0;
+#ifdef HAVE_SETITIMER
+    struct itimerval it;
+#endif
+    max_size_t totLen = 0;
+    double time1, time2 = 0, tokens;
+    tokens=0;
+
+#ifdef HAVE_CLOCK_GETTIME
+    struct timespec t1; 
+    clock_gettime(CLOCK_REALTIME, &t1);
+    time1 = t1.tv_sec + (t1.tv_nsec / 1000000000.0);
+#else 
+    struct timeval t1;
+    gettimeofday( &t1, NULL );
+    time1 = t1.tv_sec + (t1.tv_usec / 1000000.0);
+#endif    
+
+    char* readAt = mBuf;
+
+    // Indicates if the stream is readable 
+    bool canRead = true, mMode_Time = isModeTime( mSettings ); 
+
+    ReportStruct *reportstruct = NULL;
+
+    // InitReport handles Barrier for multiple Streams
+    mSettings->reporthdr = InitReport( mSettings );
+    reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+    reportstruct->packetID = 0;
+    reportstruct->emptyreport=0;
+    reportstruct->socket = mSettings->mSock;
+    
+    lastPacketTime.setnow();
+    if ( mMode_Time ) {
+#ifdef HAVE_SETITIMER
+        int err;
+	memset (&it, 0, sizeof (it));
+	it.it_value.tv_sec = (int) (mSettings->mAmount / 100.0);
+	it.it_value.tv_usec = (int) (10000 * (mSettings->mAmount -
+                                     it.it_value.tv_sec * 100.0));
+	err = setitimer( ITIMER_REAL, &it, NULL );
+	FAIL_errno( err != 0, "setitimer", mSettings);
+#else 
+        mEndTime.setnow();
+	mEndTime.add( mSettings->mAmount / 100.0 );
+#endif 
+    }
+    while (1) {
+        // Read the next data block from 
+        // the file if it's file input 
+        if ( isFileInput( mSettings ) ) {
+            Extractor_getNextDataBlock( readAt, mSettings ); 
+            canRead = Extractor_canRead( mSettings ) != 0; 
+        } else
+            canRead = true; 
+	// Add tokens per the loop time
+	// clock_gettime is much cheaper than gettimeofday() so 
+	// use it if possible. 
+#ifdef HAVE_CLOCK_GETTIME
+	clock_gettime(CLOCK_REALTIME, &t1);
+	time2 = t1.tv_sec + (t1.tv_nsec / 1000000000.0);
+	tokens += (time2 - time1) * (mSettings->mUDPRate / 8.0);
+	time1 = time2;
+#else 
+	if (!time2) 
+	    gettimeofday( &t1, NULL );
+	time2 = t1.tv_sec + (t1.tv_usec / 1000000.0);
+	tokens += (time2 - time1) * (mSettings->mUDPRate / 8.0);
+	time1 = time2;
+	time2 = 0;
+#endif    
+	if (tokens >= 0) { 
+	    // perform write 
+	    reportstruct->errwrite=0;
+	    currLen = write( mSettings->mSock, mBuf, mSettings->mBufLen );
+	    if ( currLen < 0 ) {
+		reportstruct->errwrite=1;
+		currLen = 0;
+		if (
+#ifdef WIN32
+		    (errno = WSAGetLastError()) != WSAETIMEDOUT
+#else
+		    errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR
+#endif
+		    ) {
+		    WARN_errno( 1 , "write");
+		    break;
+		}
+	    }
+	    // Consume tokens per the transmit
+	    tokens -= currLen;
+	    totLen += currLen;
+
+#ifndef HAVE_SETITIMER
+	    // Get the time for so the loop can 
+	    // end if the running time exceeds the requested
+	    gettimeofday( &(reportstruct->packetTime), NULL );
+# ifndef HAVE_CLOCK_GETTIME
+	    // leverage the packet gettimeofday reducing
+	    // these sys calls (which can be expensive)
+	    // time2 is used for the token bucket adjust
+	    time2 = reportstruct->packetTime.tv_sec + (reportstruct->packetTime.tv_usec / 1000000.0);
+# endif
+#endif
+	    if(mSettings->mInterval > 0) {
+#ifdef HAVE_SETITIMER
+		gettimeofday( &(reportstruct->packetTime), NULL );
+# ifndef HAVE_CLOCK_GETTIME
+		// leverage the packet gettimeofday reducing
+		// these sys calls (which can be expensive)
+		time2 = reportstruct->packetTime.tv_sec + (reportstruct->packetTime.tv_usec / 1000000.0);
+# endif
+#endif
+		reportstruct->packetLen = currLen;
+		ReportPacket( mSettings->reporthdr, reportstruct );
+	    }	
+
+	    if ( !mMode_Time ) {
+		/* mAmount may be unsigned, so don't let it underflow! */
+		if( mSettings->mAmount >= (unsigned long) currLen ) {
+		    mSettings->mAmount -= (unsigned long) currLen;
+		} else {
+		    mSettings->mAmount = 0;
+		}
+	    }
+        } else {
+	    // Use a 4 usec delay to fill tokens
+	    delay_loop(4);
+	}
+#ifdef HAVE_SETITIMER
+	if (sInterupted || 
+	    (!mMode_Time  && (mSettings->mAmount <= 0 || !canRead)))
+	    break;
+#else 
+	if (sInterupted || 
+	    (mMode_Time   &&  mEndTime.before(reportstruct->packetTime))  || 
+	    (!mMode_Time  && (mSettings->mAmount <= 0 || !canRead)))
+	    break;
+#endif	
+    }
+
+    // stop timing
+    gettimeofday( &(reportstruct->packetTime), NULL );
+
+    // if we're not doing interval reporting, report the entire transfer as one big packet
+    if(0.0 == mSettings->mInterval) {
+        reportstruct->packetLen = totLen;
+        ReportPacket( mSettings->reporthdr, reportstruct );
+    }
+    CloseReport( mSettings->reporthdr, reportstruct );
+
+    DELETE_PTR( reportstruct );
+    EndReport( mSettings->reporthdr );
+}
+
+void Client::RunTCP( void ) {
+    int currLen = 0;
+    max_size_t totLen = 0;
+
+    char* readAt = mBuf;
+
+    // Indicates if the stream is readable 
+    bool canRead = true, mMode_Time = isModeTime( mSettings ); 
+
+    ReportStruct *reportstruct = NULL;
+
+    // InitReport handles Barrier for multiple Streams
+    mSettings->reporthdr = InitReport( mSettings );
+    reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+
+    reportstruct->packetID = 0;
+    reportstruct->emptyreport=0;
+    reportstruct->socket = mSettings->mSock;
+
+    lastPacketTime.setnow();
+
+    /*
+     * Terminate the thread by setitimer's alarm (if possible)
+     * as the alarm will break a blocked syscall (i.e. the write)
+     * and provide for accurate timing. Otherwise the thread cannot 
+     * terminate until the write completes and since this is 
+     * a blocking write the time may not be exact to the request. 
+     *
+     * In this case of no setitimer we're just using the gettimeofday
+     * calls to determine if the loop time exceeds the request time
+     * and the blocking writes will affect timing.  The socket has set 
+     * SO_SNDTIMEO to 1/2 the overall time (which should help limit 
+     * gross error) or 1/2 the report interval time (better precision)
+     *
+     * Side note: The advantage of not using interval reports is that
+     * the code path won't make any gettimeofday calls in the main loop
+     * which are expensive syscalls.
+     */ 
+    if ( mMode_Time ) {
+#ifdef HAVE_SETITIMER
+        int err;
+        struct itimerval it;
+	memset (&it, 0, sizeof (it));
+	it.it_value.tv_sec = (int) (mSettings->mAmount / 100.0);
+	it.it_value.tv_usec = (int) (10000 * (mSettings->mAmount -
+					      it.it_value.tv_sec * 100.0));
+	err = setitimer( ITIMER_REAL, &it, NULL );
+	FAIL_errno( err != 0, "setitimer", mSettings ); 
+#else
+        mEndTime.setnow();
+        mEndTime.add( mSettings->mAmount / 100.0 );
+#endif
+    }
+    while (1) {
+        // Read the next data block from 
+        // the file if it's file input 
+        if ( isFileInput( mSettings ) ) {
+	    Extractor_getNextDataBlock( readAt, mSettings ); 
+            canRead = Extractor_canRead( mSettings ) != 0; 
+        } else
+            canRead = true; 
+
+        // perform write 
+	reportstruct->errwrite=0;
+        currLen = write( mSettings->mSock, mBuf, mSettings->mBufLen );
+        if ( currLen < 0 ) {
+	    reportstruct->errwrite=1;
+	    currLen = 0;
+	    if (
+#ifdef WIN32
+		(errno = WSAGetLastError()) != WSAETIMEDOUT
+#else
+		errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR
+#endif
+		) {
+	        WARN_errno( 1, "write" );
+	        break;
+	    }
+        }
+
+	totLen += currLen;
+#ifndef HAVE_SETITIMER
+	gettimeofday( &(reportstruct->packetTime), NULL );
+#endif
+	if(mSettings->mInterval > 0) {
+#ifdef HAVE_SETITIMER
+    	    gettimeofday( &(reportstruct->packetTime), NULL );
+#endif
+            reportstruct->packetLen = currLen;
+            ReportPacket( mSettings->reporthdr, reportstruct );
+        }	
+
+        if ( !mMode_Time ) {
+            /* mAmount may be unsigned, so don't let it underflow! */
+            if( mSettings->mAmount >= (unsigned long) currLen ) {
+                mSettings->mAmount -= (unsigned long) currLen;
+            } else {
+                mSettings->mAmount = 0;
+            }
+        }
+#ifdef HAVE_SETITIMER
+	if (sInterupted || 
+	    (!mMode_Time  && (mSettings->mAmount <= 0 || !canRead)))
+	    break;
+#else 
+	if (sInterupted || 
+	    (mMode_Time   &&  mEndTime.before(reportstruct->packetTime))  || 
+	    (!mMode_Time  && (mSettings->mAmount <= 0 || !canRead)))
+	    break;
+#endif	
+    }
+		  
+
+    // stop timing
+    gettimeofday( &(reportstruct->packetTime), NULL );
+
+    // if we're not doing interval reporting, report the entire transfer as one big packet
+    if(0.0 == mSettings->mInterval) {
+        reportstruct->packetLen = totLen;
+        ReportPacket( mSettings->reporthdr, reportstruct );
+    }
+    CloseReport( mSettings->reporthdr, reportstruct );
+
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
+
+    EndReport( mSettings->reporthdr );
+}
+
+/* ------------------------------------------------------------------- 
+ * Send data using the connected UDP/TCP socket, 
+ * until a termination flag is reached. 
+ * Does not close the socket. 
+ * ------------------------------------------------------------------- */ 
+
+void Client::Run( void ) {
+    struct UDP_datagram* mBuf_UDP = (struct UDP_datagram*) mBuf; 
+    int currLen; 
+
+    double delay_target = 0; 
+    double delay = 0; 
+    double adjust = 0;
+    double delay_lower_bounds;
+
+    char* readAt = mBuf;
+
+    //  Enable socket write timeouts for responsive reporting
+    //  Do this after the connection establishment
+    //  and after Client::InitiateServer as during thes
+    //  default socket timeouts are preferred.
+    {
+	int sosndtimer = 0;
+	// sosndtimer units microseconds
+	if (mSettings->mInterval) {
+	    sosndtimer = (int) (mSettings->mInterval * 1000000) / 2;
+	} else if (isModeTime(mSettings)) {
+	    sosndtimer = (mSettings->mAmount * 10000) / 2;
+	} 
+        // units nanoseconds for delay bounds
+	delay_lower_bounds = (double) sosndtimer * -1e3;
+
+	if (sosndtimer > 0) {
+#ifdef WIN32
+            // Windows SO_RCVTIMEO uses ms
+	    DWORD timeout = (double) sosndtimer / 1e3;
+#else
+	    struct timeval timeout;
+	    timeout.tv_sec = sosndtimer / 1000000;
+	    timeout.tv_usec = sosndtimer % 1000000;
+#endif
+	    if (setsockopt( mSettings->mSock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout)) < 0 ) {
+		WARN_errno( mSettings->mSock == SO_SNDTIMEO, "socket" );
+	    }
+	}
+    }
+
+#if HAVE_THREAD
+    if ( !isUDP( mSettings ) ) {
+	if (mSettings->mUDPRate > 0)
+	    RunRateLimitedTCP();
+	else 
+	    RunTCP();
+	return;
+    }
+#endif
+    
+    // Indicates if the stream is readable 
+    bool canRead = true, mMode_Time = isModeTime( mSettings ); 
+
+    // setup termination variables
+    if ( mMode_Time ) {
+        mEndTime.setnow();
+        mEndTime.add( mSettings->mAmount / 100.0 );
+    }
+
+    if ( isUDP( mSettings ) ) {
+#ifdef HAVE_SCHED_SETSCHEDULER
+	if ( isRealtime( mSettings ) ) {
+	    // Thread settings to support realtime operations
+	    // SCHED_OTHER, SCHED_FIFO, SCHED_RR
+	    struct sched_param sp;
+	    sp.sched_priority = sched_get_priority_max(SCHED_RR); 
+
+	    if (sched_setscheduler(0, SCHED_RR, &sp) < 0) {
+                WARN_errno( 1, "Client set scheduler" );
+#ifdef HAVE_MLOCKALL
+	    } else if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) { 
+		// lock the threads memory
+		WARN_errno( 1, "mlockall");
+#endif
+	    }
+	}
+#endif
+	// compute delay target in units of nanoseconds
+	if (mSettings->mUDPRateUnits == kRate_BW) { 
+	    // compute delay for bandwidth restriction, constrained to [0,1] seconds 
+	    delay_target = (double) ( mSettings->mBufLen * ((kSecs_to_nsecs * kBytes_to_Bits) 
+							    / mSettings->mUDPRate) );
+	} else {
+	    delay_target = 1e9 / mSettings->mUDPRate;
+	}
+	if ( delay_target < 0  || 
+             delay_target > 1.0 * kSecs_to_nsecs ) {
+            fprintf( stderr, warn_delay_large, delay_target / kSecs_to_nsecs ); 
+            delay_target = 1.0 * kSecs_to_nsecs; 
+        }
+        if ( isFileInput( mSettings ) ) {
+	    // Due to the UDP timestamps etc, included 
+	    // reduce the read size by an amount 
+	    // equal to the header size
+            if ( isCompat( mSettings ) ) {
+                Extractor_reduceReadSize( sizeof(struct UDP_datagram), mSettings );
+                readAt += sizeof(struct UDP_datagram);
+            } else {
+                Extractor_reduceReadSize( sizeof(struct UDP_datagram) +
+                                          sizeof(struct client_hdr), mSettings );
+                readAt += sizeof(struct UDP_datagram) +
+		    sizeof(struct client_hdr);
+            }
+        }
+    }
+
+    ReportStruct *reportstruct = NULL;
+
+    // InitReport handles Barrier for multiple Streams
+    mSettings->reporthdr = InitReport( mSettings );
+    reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+    reportstruct->packetID = 0;
+    reportstruct->emptyreport=0;
+    reportstruct->errwrite=0;
+    reportstruct->socket = mSettings->mSock;
+
+    lastPacketTime.setnow();
+    // Set this to > 0 so first loop iteration will delay the IPG
+    currLen = 1;
+
+    do {
+
+        // Test case: drop 17 packets and send 2 out-of-order: 
+        // sequence 51, 52, 70, 53, 54, 71, 72 
+        //switch( datagramID ) { 
+        //  case 53: datagramID = 70; break; 
+        //  case 71: datagramID = 53; break; 
+        //  case 55: datagramID = 71; break; 
+        //  default: break; 
+        //} 
+#ifdef HAVE_CLOCK_GETTIME
+	struct timespec t1; 
+	clock_gettime(CLOCK_REALTIME, &t1);
+	reportstruct->packetTime.tv_sec = t1.tv_sec;
+	reportstruct->packetTime.tv_usec = (t1.tv_nsec + 500) / 1000L;
+#else 
+        gettimeofday( &(reportstruct->packetTime), NULL );
+#endif    
+        if ( isUDP( mSettings ) ) {
+            // store datagram ID into buffer 
+            mBuf_UDP->id      = htonl( (reportstruct->packetID)++ ); 
+            mBuf_UDP->tv_sec  = htonl( reportstruct->packetTime.tv_sec ); 
+            mBuf_UDP->tv_usec = htonl( reportstruct->packetTime.tv_usec );
+
+            // Adjustment for the running delay
+	    // o measure how long the last loop iteration took
+	    // o calculate the delay adjust
+	    //   - If write succeeded, adjust = target IPG - the loop time
+	    //   - If write failed, adjust = the loop time
+	    // o then adjust the overall running delay
+	    // Note: adjust units are nanoseconds, 
+	    //       packet timestamps are microseconds
+	    if (currLen > 0) 
+	      adjust = delay_target + \
+		       (1000.0 * lastPacketTime.subUsec( reportstruct->packetTime )); 
+	    else 
+	      adjust = 1000.0 * lastPacketTime.subUsec( reportstruct->packetTime );
+
+            lastPacketTime.set( reportstruct->packetTime.tv_sec, 
+				reportstruct->packetTime.tv_usec );
+	    // Since linux nanosleep/busyloop can exceed delay 
+	    // there are two possible equilibriums
+	    //  1)  Try to perserve inter packet gap 
+	    //  2)  Try to perserve requested transmit rate
+	    // The latter seems preferred, hence use a running delay 
+	    // that spans the life of the thread and constantly adjust.
+	    // A negative delay means the iperf app is behind.
+	    delay += adjust;
+	    // Don't let delay grow unbounded
+	    if (delay < delay_lower_bounds) {
+		delay = delay_target;
+	    }
+
+        }
+
+        // Read the next data block from 
+        // the file if it's file input 
+        if ( isFileInput( mSettings ) ) {
+            Extractor_getNextDataBlock( readAt, mSettings ); 
+            canRead = Extractor_canRead( mSettings ) != 0; 
+        } else
+            canRead = true; 
+
+        // perform write 
+        currLen = write( mSettings->mSock, mBuf, mSettings->mBufLen );
+        if ( currLen < 0 ) {
+	    reportstruct->errwrite = 1; 
+	    reportstruct->packetID--;
+	    reportstruct->emptyreport=1; 
+	    currLen = 0;
+	    if (
+#ifdef WIN32
+		(errno = WSAGetLastError()) != WSAETIMEDOUT &&
+		errno != WSAECONNREFUSED
+#else
+		errno != EAGAIN && errno != EWOULDBLOCK &&
+		errno != EINTR  && errno != ECONNREFUSED
+#endif
+		) {
+	        WARN_errno( 1, "write" );
+	        break;
+	    }
+	}
+
+        // report packets 
+        reportstruct->packetLen = (unsigned long) currLen;
+        ReportPacket( mSettings->reporthdr, reportstruct );
+
+	// Insert delay here only if the running delay is greater than 1 usec, 
+        // otherwise don't delay and immediately continue with the next tx.  
+        if ( delay >= 1000 ) {
+	    // Convert from nanoseconds to microseconds
+	    // and invoke the microsecond delay
+	    delay_loop((unsigned long) (delay / 1000)); 
+        }
+        if ( !mMode_Time ) {
+            /* mAmount may be unsigned, so don't let it underflow! */
+            if( mSettings->mAmount >= (unsigned long) currLen ) {
+                mSettings->mAmount -= (unsigned long) currLen;
+            } else {
+                mSettings->mAmount = 0;
+            }
+        }
+
+    } while ( ! (sInterupted  || 
+                 (mMode_Time   &&  mEndTime.before( reportstruct->packetTime ))  || 
+                 (!mMode_Time  &&  0 >= mSettings->mAmount)) && canRead ); 
+
+    // stop timing
+    gettimeofday( &(reportstruct->packetTime), NULL );
+    CloseReport( mSettings->reporthdr, reportstruct );
+
+    if ( isUDP( mSettings ) ) {
+        // send a final terminating datagram 
+        // Don't count in the mTotalLen. The server counts this one, 
+        // but didn't count our first datagram, so we're even now. 
+        // The negative datagram ID signifies termination to the server. 
+    
+        // store datagram ID into buffer 
+        mBuf_UDP->id      = htonl( -(reportstruct->packetID)  ); 
+        mBuf_UDP->tv_sec  = htonl( reportstruct->packetTime.tv_sec ); 
+        mBuf_UDP->tv_usec = htonl( reportstruct->packetTime.tv_usec ); 
+
+        if ( isMulticast( mSettings ) ) {
+            ssize_t ret = write( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+            if (ret < 0) {
+                DEBUGP("%s[%d]: write error!! ret=%zd(%d)", __FILE__, (int)__LINE__, ret, errno);
+            }
+
+        } else {
+            write_UDP_FIN( ); 
+        }
+    }
+
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
+
+    EndReport( mSettings->reporthdr );
+} 
+// end Run
+
+void Client::InitiateServer() {
+    if ( !isCompat( mSettings ) ) {
+        int currLen;
+        client_hdr* temp_hdr = NULL;
+        if ( isUDP( mSettings ) ) {
+            UDP_datagram *UDPhdr = (UDP_datagram *)mBuf;
+            temp_hdr = (client_hdr*)(UDPhdr + 1);
+        } else {
+            temp_hdr = (client_hdr*)mBuf;
+        }
+        Settings_GenerateClientHdr( mSettings, temp_hdr );
+        if ( !isUDP( mSettings ) ) {
+            currLen = send( mSettings->mSock, mBuf, sizeof(client_hdr), 0 );
+            if ( currLen < 0 ) {
+                WARN_errno( currLen < 0, "write1" );
+            }
+        }
+    }
+}
+
+/* -------------------------------------------------------------------
+ * Setup a socket connected to a server.
+ * If inLocalhost is not null, bind to that address, specifying
+ * which outgoing interface to use.
+ * ------------------------------------------------------------------- */
+
+void Client::Connect( ) {
+    int rc;
+    SockAddr_remoteAddr( mSettings );
+
+    assert( mSettings->inHostname != NULL );
+
+    // create an internet socket
+    int type = ( isUDP( mSettings )  ?  SOCK_DGRAM : SOCK_STREAM);
+
+    int domain = (SockAddr_isIPv6( &mSettings->peer ) ? 
+#ifdef HAVE_IPV6
+                  AF_INET6
+#else
+                  AF_INET
+#endif
+                  : AF_INET);
+
+    mSettings->mSock = socket( domain, type, 0 );
+    WARN_errno( mSettings->mSock == INVALID_SOCKET, "socket" );
+
+    SetSocketOptions( mSettings );
+
+    SockAddr_localAddr( mSettings );
+    if ( mSettings->mLocalhost != NULL ) {
+        // bind socket to local address
+        rc = bind( mSettings->mSock, (sockaddr*) &mSettings->local, 
+                   SockAddr_get_sizeof_sockaddr( &mSettings->local ) );
+        WARN_errno( rc == SOCKET_ERROR, "bind" );
+    }
+    // connect socket
+    rc = connect( mSettings->mSock, (sockaddr*) &mSettings->peer, 
+                  SockAddr_get_sizeof_sockaddr( &mSettings->peer ));
+    FAIL_errno( rc == SOCKET_ERROR, "connect", mSettings );
+
+    getsockname( mSettings->mSock, (sockaddr*) &mSettings->local, 
+                 &mSettings->size_local );
+    getpeername( mSettings->mSock, (sockaddr*) &mSettings->peer,
+                 &mSettings->size_peer );
+} // end Connect
+
+/* ------------------------------------------------------------------- 
+ * Send a datagram on the socket. The datagram's contents should signify 
+ * a FIN to the application. Keep re-transmitting until an 
+ * acknowledgement datagram is received. 
+ * ------------------------------------------------------------------- */ 
+
+void Client::write_UDP_FIN( ) {
+    int rc; 
+    fd_set readSet; 
+    struct timeval timeout; 
+    struct UDP_datagram* mBuf_UDP = (struct UDP_datagram*) mBuf;
+    ssize_t ret = 0;
+
+    int count = 0; 
+    int packetid;
+    while ( count < 10 ) {
+        count++; 
+
+        // write data 
+        ret = write( mSettings->mSock, mBuf, mSettings->mBufLen );
+        if (ret < 0) {
+            printf("%s[%d]: write error!! ret=%zd(%d)\n", __FILE__, (int)__LINE__, ret, errno);
+        }
+	// decrement the packet count
+	packetid = ntohl(mBuf_UDP->id);
+        mBuf_UDP->id = htonl(--packetid); 
+
+        // wait until the socket is readable, or our timeout expires 
+        FD_ZERO( &readSet ); 
+        FD_SET( mSettings->mSock, &readSet ); 
+        timeout.tv_sec  = 0; 
+        timeout.tv_usec = 250000; // quarter second, 250 ms 
+
+        rc = select( mSettings->mSock+1, &readSet, NULL, NULL, &timeout ); 
+        FAIL_errno( rc == SOCKET_ERROR, "select", mSettings ); 
+
+        if ( rc == 0 ) {
+            // select timed out 
+            continue; 
+        } else {
+            int len = sizeof(UDP_datagram) + sizeof(server_hdr);
+            char buf[300];
+            memset(buf, 0x00, sizeof(buf));
+            UDP_datagram* udp = (UDP_datagram*)buf;
+            // socket ready to read 
+            rc = read( mSettings->mSock, buf, len ); 
+            WARN_errno( rc < 0, "read" );
+    	    if ( rc < 0 ) {
+                printf("%s[%d]: read error!! rc=%d(%d)\n", __FILE__, (int)__LINE__, rc, errno);
+                break;
+            } else {
+                ReportServerUDP( mSettings, (server_hdr*) ((UDP_datagram*)udp + 1) );
+            }
+
+            return; 
+        } 
+    } 
+
+    fprintf( stderr, warn_no_ack, mSettings->mSock, count ); 
+} 
+// end write_UDP_FIN 
diff -uprN iperf-2.0.9.orig/src/Launch.cpp iperf-2.0.9/src/Launch.cpp
--- iperf-2.0.9.orig/src/Launch.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Launch.cpp	2017-02-11 02:06:37.186429074 +0900
@@ -61,6 +61,12 @@
 #include "Server.hpp"
 #include "PerfSocket.hpp"
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /*
  * listener_spawn is responsible for creating a Listener class
  * and launching the listener. It is provided as a means for
@@ -71,10 +77,15 @@ void listener_spawn( thread_Settings *th
 
     // start up a listener
     theListener = new Listener( thread );
+    DEBUGP("%s[%d]: new Listener: %p\n", __FILE__, (int)__LINE__, theListener);
 
     // Start listening
     theListener->Run();
-    DELETE_PTR( theListener );
+    if (theListener != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, theListener);
+        DELETE_PTR( theListener );
+        theListener = NULL;
+    }
 }
 
 /*
@@ -87,10 +98,15 @@ void server_spawn( thread_Settings *thre
 
     // Start up the server
     theServer = new Server( thread );
-    
+    DEBUGP("%s[%d]: new Server: %p\n", __FILE__, (int)__LINE__, theServer);
+
     // Run the test
     theServer->Run();
-    DELETE_PTR( theServer);
+    if (theServer != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, theServer);
+        DELETE_PTR( theServer );
+        theServer = NULL;
+    }
 }
 
 /*
@@ -103,6 +119,7 @@ void client_spawn( thread_Settings *thre
 
     //start up the client
     theClient = new Client( thread );
+    DEBUGP("%s[%d]: new Client: %p\n", __FILE__, (int)__LINE__, theClient);
 
     // Let the server know about our settings
     theClient->InitiateServer();
@@ -110,6 +127,11 @@ void client_spawn( thread_Settings *thre
     // Run the test
     theClient->Run();
     DELETE_PTR( theClient );
+    if (theClient != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, theClient);
+        DELETE_PTR( theClient );
+        theClient = NULL;
+    }
 }
 
 /*
@@ -135,6 +157,7 @@ void client_init( thread_Settings *clien
     Mutex_Lock( &groupCond );
     groupID--;
     clients->multihdr = InitMulti( clients, groupID );
+    DEBUGP("%s[%d]: InitMulti: %p\n", __FILE__, (int)__LINE__, clients->multihdr);
     Mutex_Unlock( &groupCond );
 
 #ifdef HAVE_THREAD
@@ -150,6 +173,8 @@ void client_init( thread_Settings *clien
     // to the list of threads to start
     for (int i = 1; i < clients->mThreads; i++) {
         Settings_Copy( clients, &next );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, next);
+
         unsetReport( next );
         itr->runNow = next;
         itr = next;
diff -uprN iperf-2.0.9.orig/src/List.cpp iperf-2.0.9/src/List.cpp
--- iperf-2.0.9.orig/src/List.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/List.cpp	2017-02-11 02:06:37.186429074 +0900
@@ -54,6 +54,12 @@
 #include "Mutex.h"
 #include "SocketAddr.h"
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /*
  * Global List and Mutex variables
  */
@@ -86,7 +92,11 @@ void Iperf_delete ( iperf_sockaddr *del,
                 itr = itr->next;
             }
         }
-        delete temp;
+        if (temp != NULL) {
+   	        DEBUGP("%s[%d]: delete: %p\n", __FILE__, (int)__LINE__, temp);
+            delete temp;
+            temp = NULL;
+        }
     }
 }
 
@@ -97,7 +107,11 @@ void Iperf_destroy ( Iperf_ListEntry **r
     Iperf_ListEntry *itr1 = *root, *itr2;
     while ( itr1 != NULL ) {
         itr2 = itr1->next;
-        delete itr1;
+        if (itr1 != NULL) {
+            DEBUGP("%s[%d]: delete: %p\n", __FILE__, (int)__LINE__, itr1);
+            delete itr1;
+            itr1 = NULL;
+        }
         itr1 = itr2;
     }
     *root = NULL;
diff -uprN iperf-2.0.9.orig/src/Listener.cpp iperf-2.0.9/src/Listener.cpp
--- iperf-2.0.9.orig/src/Listener.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Listener.cpp	2017-02-13 07:38:27.848802764 +0900
@@ -80,6 +80,12 @@
 #include "List.h"
 #include "util.h" 
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /* ------------------------------------------------------------------- 
  * Stores local hostname and socket info. 
  * ------------------------------------------------------------------- */ 
@@ -92,6 +98,7 @@ Listener::Listener( thread_Settings *inS
 
     // initialize buffer
     mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
 
     // open listening socket 
     Listen( ); 
@@ -103,13 +110,21 @@ Listener::Listener( thread_Settings *inS
  * Delete memory (buffer). 
  * ------------------------------------------------------------------- */ 
 Listener::~Listener() {
+    DEBUGP("%s[%d]: Listener::~Listener\n", __FILE__, (int)__LINE__);
     if ( mSettings->mSock != INVALID_SOCKET ) {
+        DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
         int rc = close( mSettings->mSock );
         WARN_errno( rc == SOCKET_ERROR, "close" );
         mSettings->mSock = INVALID_SOCKET;
     }
-    DELETE_ARRAY( mBuf );
-} // end ~Listener 
+
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELTE_ARRAY: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+   	}
+}
+
 
 /* ------------------------------------------------------------------- 
  * Listens for connections and starts Servers to handle data. 
@@ -139,7 +154,8 @@ void Listener::Run( void ) {
     {
         bool client = false, UDP = isUDP( mSettings ), mCount = (mSettings->mThreads != 0);
         thread_Settings *tempSettings = NULL;
-        Iperf_ListEntry *exist, *listtemp;
+        Iperf_ListEntry *exist = NULL;
+        Iperf_ListEntry *listtemp = NULL;
         client_hdr* hdr = ( UDP ? (client_hdr*) (((UDP_datagram*)mBuf) + 1) : 
                                   (client_hdr*) mBuf);
         
@@ -147,7 +163,10 @@ void Listener::Run( void ) {
             client = true;
             SockAddr_remoteAddr( mSettings );
         }
+
         Settings_Copy( mSettings, &server );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
         server->mThreadMode = kMode_Server;
     
     
@@ -173,6 +192,7 @@ sInterupted == SIGALRM
 		    ) {
 		    sInterupted = 0;
 		} else {
+            DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
 		    close( server->mSock );
 		    break;
 		}
@@ -206,6 +226,8 @@ sInterupted == SIGALRM
     
             // Create an entry for the connection list
             listtemp = new Iperf_ListEntry;
+            DEBUGP("%s[%d]: new Iperf_ListEntry: %p\n", __FILE__, (int)__LINE__, listtemp);
+
             memcpy(listtemp, &server->peer, sizeof(iperf_sockaddr));
             listtemp->next = NULL;
     
@@ -222,6 +244,7 @@ sInterupted == SIGALRM
                 Mutex_Lock( &groupCond );
                 groupID--;
                 listtemp->holder = InitMulti( server, groupID );
+                DEBUGP("%s[%d]: InitMulti: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
                 server->multihdr = listtemp->holder;
                 Mutex_Unlock( &groupCond );
             }
@@ -283,11 +306,40 @@ sInterupted == SIGALRM
             if ( !isSingleClient( mSettings ) ) {
                 mClients--;
             }
+
+            /*
+            if (server != NULL) {
+               DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+               Settings_Destroy( server );
+               server = NULL;
+            }
+            */
+
             Settings_Copy( mSettings, &server );
+            DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
             server->mThreadMode = kMode_Server;
+
+            if ((listtemp != NULL) && (listtemp->holder != NULL)) {
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+                // listtemp is deleted by Server::Run
+                free(listtemp->holder);
+                listtemp->holder = NULL;
+            }
+
+            if (tempSettings != NULL) {
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, tempSettings);
+                free(tempSettings);
+                tempSettings = NULL;
+        	}
+
         } while ( !sInterupted && (!mCount || ( mCount && mClients > 0 )) );
-    
-        Settings_Destroy( server );
+
+        if (server != NULL) {
+            DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+            Settings_Destroy( server );
+            server = NULL;
+        }
     }
 } // end Run 
 
@@ -512,12 +564,14 @@ void Listener::UDPSingleServer( ) {
     
     bool client = false, UDP = isUDP( mSettings ), mCount = (mSettings->mThreads != 0);
     thread_Settings *tempSettings = NULL;
-    Iperf_ListEntry *exist, *listtemp;
+    Iperf_ListEntry *exist = NULL;
+    Iperf_ListEntry *listtemp = NULL;
     int rc;
     int32_t datagramID;
     client_hdr* hdr = ( UDP ? (client_hdr*) (((UDP_datagram*)mBuf) + 1) : 
                               (client_hdr*) mBuf);
     ReportStruct *reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
     bool mMode_Time = isServerModeTime( mSettings ) && !isDaemon( mSettings );
     // setup termination variables
     if ( mMode_Time ) {
@@ -530,6 +584,7 @@ void Listener::UDPSingleServer( ) {
         SockAddr_remoteAddr( mSettings );
     }
     Settings_Copy( mSettings, &server );
+    DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
     server->mThreadMode = kMode_Server;
 
 
@@ -634,7 +689,11 @@ void Listener::UDPSingleServer( ) {
                     }
                     EndReport( exist->server->reporthdr );
                     exist->server->reporthdr = NULL;
-                    Iperf_delete( &(exist->server->peer), &clients );
+                    if (clients == NULL) {
+                        DEBUGP("%s[%d]: Iperf_delete: %p\n", __FILE__, (int)__LINE__, clients);
+                        Iperf_delete( &(exist->server->peer), &clients );
+                        clients = NULL;
+                    }
                 } else if ( rc > (int) ( sizeof( UDP_datagram )
                                                   + sizeof( server_hdr ) ) ) {
                     UDP_datagram *UDP_Hdr;
@@ -652,6 +711,7 @@ void Listener::UDPSingleServer( ) {
             break;
         }
         if ( sInterupted != 0 ) {
+            DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
             close( server->mSock );
             break;
         }
@@ -676,6 +736,7 @@ void Listener::UDPSingleServer( ) {
                 connect( mSettings->mSock, 
                          (sockaddr*) &server->peer, 
                          server->size_peer );
+                DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
                 close( mSettings->mSock );
                 mSettings->mSock = -1; 
                 Listen( );
@@ -685,6 +746,7 @@ void Listener::UDPSingleServer( ) {
 
         // Create an entry for the connection list
         listtemp = new Iperf_ListEntry;
+        DEBUGP("%s[%d]: new Iperf_ListEntry: %p\n", __FILE__, (int)__LINE__, listtemp);
         memcpy(listtemp, &server->peer, sizeof(iperf_sockaddr));
         listtemp->server = server;
         listtemp->next = NULL;
@@ -701,6 +763,7 @@ void Listener::UDPSingleServer( ) {
             Mutex_Lock( &groupCond );
             groupID--;
             listtemp->holder = InitMulti( server, groupID );
+            DEBUGP("%s[%d]: InitMulti: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
             server->multihdr = listtemp->holder;
             Mutex_Unlock( &groupCond );
         }
@@ -733,12 +796,41 @@ void Listener::UDPSingleServer( ) {
         if ( !isSingleClient( mSettings ) ) {
             mClients--;
         }
+
+        /*
+        if (server != NULL) {
+            DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+            Settings_Destroy( server );
+            server = NULL;
+        }
+        */
+
         Settings_Copy( mSettings, &server );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
         server->mThreadMode = kMode_Server;
+
+        if ((listtemp != NULL) && (listtemp->holder != NULL)) {
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+            free(listtemp->holder);
+            listtemp->holder = NULL;
+        }
+
     } while ( !sInterupted && (!mCount || ( mCount && mClients > 0 )) );
     Mutex_Unlock( &clients_mutex );
 
-    Settings_Destroy( server );
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR(reportstruct);
+        reportstruct = NULL;
+    }
+
+    if (server != NULL) {
+        DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+        Settings_Destroy( server );
+        server = NULL;
+    }
+
 }
 
 
diff -uprN iperf-2.0.9.orig/src/Listener.cpp.~1~ iperf-2.0.9/src/Listener.cpp.~1~
--- iperf-2.0.9.orig/src/Listener.cpp.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Listener.cpp.~1~	2017-02-11 02:06:37.186429074 +0900
@@ -0,0 +1,832 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Listener.cpp
+ * by Mark Gates <mgates@nlanr.net> 
+ * &  Ajay Tirumala <tirumala@ncsa.uiuc.edu> 
+ * ------------------------------------------------------------------- 
+ * Listener sets up a socket listening on the server host. For each 
+ * connected socket that accept() returns, this creates a Server 
+ * socket and spawns a thread for it. 
+ * 
+ * Changes to the latest version. Listener will run as a daemon 
+ * Multicast Server is now Multi-threaded 
+ * ------------------------------------------------------------------- 
+ * headers 
+ * uses 
+ *   <stdlib.h> 
+ *   <stdio.h> 
+ *   <string.h> 
+ *   <errno.h> 
+ * 
+ *   <sys/types.h> 
+ *   <unistd.h> 
+ * 
+ *   <netdb.h> 
+ *   <netinet/in.h> 
+ *   <sys/socket.h> 
+ * ------------------------------------------------------------------- */ 
+
+
+#define HEADERS() 
+
+#include "headers.h" 
+#include "Listener.hpp"
+#include "SocketAddr.h"
+#include "PerfSocket.hpp"
+#include "List.h"
+#include "util.h" 
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+/* ------------------------------------------------------------------- 
+ * Stores local hostname and socket info. 
+ * ------------------------------------------------------------------- */ 
+
+Listener::Listener( thread_Settings *inSettings ) {
+
+    mClients = inSettings->mThreads;
+    mBuf = NULL;
+    mSettings = inSettings;
+
+    // initialize buffer
+    mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
+
+    // open listening socket 
+    Listen( ); 
+    ReportSettings( inSettings );
+
+} // end Listener 
+
+/* ------------------------------------------------------------------- 
+ * Delete memory (buffer). 
+ * ------------------------------------------------------------------- */ 
+Listener::~Listener() {
+    DEBUGP("%s[%d]: Listener::~Listener\n", __FILE__, (int)__LINE__);
+    if ( mSettings->mSock != INVALID_SOCKET ) {
+        int rc = close( mSettings->mSock );
+        WARN_errno( rc == SOCKET_ERROR, "close" );
+        mSettings->mSock = INVALID_SOCKET;
+    }
+
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELTE_ARRAY: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+   	}
+}
+
+
+/* ------------------------------------------------------------------- 
+ * Listens for connections and starts Servers to handle data. 
+ * For TCP, each accepted connection spawns a Server thread. 
+ * For UDP, handle all data in this thread for Win32 Only, otherwise
+ *          spawn a new Server thread. 
+ * ------------------------------------------------------------------- */ 
+void Listener::Run( void ) {
+#if 0 // ifdef WIN32 removed to allow Windows to use multi-threaded UDP server 
+    if ( isUDP( mSettings ) && !isSingleUDP( mSettings ) ) {
+        UDPSingleServer();
+    } else
+#else
+#ifdef sun
+    if ( ( isUDP( mSettings ) && 
+           isMulticast( mSettings ) && 
+           !isSingleUDP( mSettings ) ) ||
+         isSingleUDP( mSettings ) ) {
+        UDPSingleServer();
+    } else
+#else
+    if ( isSingleUDP( mSettings ) ) {
+        UDPSingleServer();
+    } else
+#endif
+#endif
+    {
+        bool client = false, UDP = isUDP( mSettings ), mCount = (mSettings->mThreads != 0);
+        thread_Settings *tempSettings = NULL;
+        Iperf_ListEntry *exist = NULL;
+        Iperf_ListEntry *listtemp = NULL;
+        client_hdr* hdr = ( UDP ? (client_hdr*) (((UDP_datagram*)mBuf) + 1) : 
+                                  (client_hdr*) mBuf);
+        
+        if ( mSettings->mHost != NULL ) {
+            client = true;
+            SockAddr_remoteAddr( mSettings );
+        }
+
+        Settings_Copy( mSettings, &server );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
+        server->mThreadMode = kMode_Server;
+    
+    
+        // Accept each packet, 
+        // If there is no existing client, then start  
+        // a new thread to service the new client 
+        // The listener runs in a single thread 
+        // Thread per client model is followed 
+        do {
+            // Get a new socket
+            Accept( server );
+            if ( server->mSock == INVALID_SOCKET ) {
+                break;
+            }
+            if ( sInterupted != 0 ) {
+		// In the case of -r, ignore the clients alarm
+		if (
+#if HAVE_DECL_SIGALRM
+sInterupted == SIGALRM
+#else
+0
+#endif
+		    ) {
+		    sInterupted = 0;
+		} else {
+		    close( server->mSock );
+		    break;
+		}
+            }
+            // Reset Single Client Stuff
+            if ( isSingleClient( mSettings ) && clients == NULL ) {
+                mSettings->peer = server->peer;
+                mClients--;
+                client = true;
+                // Once all the server threads exit then quit
+                // Must keep going in case this client sends
+                // more streams
+                if ( mClients == 0 ) {
+                    thread_release_nonterm( 0 );
+                    mClients = 1;
+                }
+            }
+            // Verify that it is allowed
+            if ( client ) {
+                if ( !SockAddr_Hostare_Equal( (sockaddr*) &mSettings->peer, 
+                                              (sockaddr*) &server->peer ) ) {
+                    // Not allowed try again
+                    close( server->mSock );
+                    if ( isUDP( mSettings ) ) {
+                        mSettings->mSock = -1;
+                        Listen();
+                    }
+                    continue;
+                }
+            }
+    
+            // Create an entry for the connection list
+            listtemp = new Iperf_ListEntry;
+            DEBUGP("%s[%d]: new Iperf_ListEntry: %p\n", __FILE__, (int)__LINE__, listtemp);
+
+            memcpy(listtemp, &server->peer, sizeof(iperf_sockaddr));
+            listtemp->next = NULL;
+    
+            // See if we need to do summing
+            Mutex_Lock( &clients_mutex );
+            exist = Iperf_hostpresent( &server->peer, clients); 
+    
+            if ( exist != NULL ) {
+                // Copy group ID
+                listtemp->holder = exist->holder;
+                server->multihdr = exist->holder;
+            } else {
+                server->mThreads = 0;
+                Mutex_Lock( &groupCond );
+                groupID--;
+                listtemp->holder = InitMulti( server, groupID );
+                DEBUGP("%s[%d]: InitMulti: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+                server->multihdr = listtemp->holder;
+                Mutex_Unlock( &groupCond );
+            }
+    
+            // Store entry in connection list
+            Iperf_pushback( listtemp, &clients ); 
+            Mutex_Unlock( &clients_mutex ); 
+    
+            tempSettings = NULL;
+            if ( !isCompat( mSettings ) && !isMulticast( mSettings ) ) {
+                if ( !UDP ) {
+                    // TCP does not have the info yet
+                    if ( recv( server->mSock, (char*)hdr, sizeof(client_hdr), 0) > 0 ) {
+                        Settings_GenerateClientSettings( server, &tempSettings, 
+                                                          hdr );
+                    }
+                } else {
+                    Settings_GenerateClientSettings( server, &tempSettings, 
+                                                      hdr );
+                }
+            }
+    
+    
+            if ( tempSettings != NULL ) {
+                client_init( tempSettings );
+                if ( tempSettings->mMode == kTest_DualTest ) {
+#ifdef HAVE_THREAD
+                    server->runNow =  tempSettings;
+#else
+                    server->runNext = tempSettings;
+#endif
+                } else {
+                    server->runNext =  tempSettings;
+                }
+            }
+    
+            // Start the server
+#if defined(WIN32) && defined(HAVE_THREAD)
+            if ( UDP ) {
+                // WIN32 does bad UDP handling so run single threaded
+                if ( server->runNow != NULL ) {
+                    thread_start( server->runNow );
+                }
+                server_spawn( server );
+                if ( server->runNext != NULL ) {
+                    thread_start( server->runNext );
+                }
+            } else
+#endif
+            thread_start( server );
+    
+            // create a new socket
+            if ( UDP ) {
+                mSettings->mSock = -1; 
+                Listen( );
+            }
+    
+            // Prep for next connection
+            if ( !isSingleClient( mSettings ) ) {
+                mClients--;
+            }
+
+            /*
+            if (server != NULL) {
+               DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+               Settings_Destroy( server );
+               server = NULL;
+            }
+            */
+
+            Settings_Copy( mSettings, &server );
+            DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
+            server->mThreadMode = kMode_Server;
+
+            if ((listtemp != NULL) && (listtemp->holder != NULL)) {
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+                // listtemp is deleted by Server::Run
+                free(listtemp->holder);
+                listtemp->holder = NULL;
+            }
+
+            if (tempSettings != NULL) {
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, tempSettings);
+                free(tempSettings);
+                tempSettings = NULL;
+        	}
+
+        } while ( !sInterupted && (!mCount || ( mCount && mClients > 0 )) );
+
+        if (server != NULL) {
+            DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+            Settings_Destroy( server );
+            server = NULL;
+        }
+    }
+} // end Run 
+
+/* -------------------------------------------------------------------
+ * Setup a socket listening on a port.
+ * For TCP, this calls bind() and listen().
+ * For UDP, this just calls bind().
+ * If inLocalhost is not null, bind to that address rather than the
+ * wildcard server address, specifying what incoming interface to
+ * accept connections on.
+ * ------------------------------------------------------------------- */
+void Listener::Listen( ) {
+    int rc;
+
+    SockAddr_localAddr( mSettings );
+
+    // create an internet TCP socket
+    int type = (isUDP( mSettings )  ?  SOCK_DGRAM  :  SOCK_STREAM);
+    int domain = (SockAddr_isIPv6( &mSettings->local ) ? 
+#ifdef HAVE_IPV6
+                  AF_INET6
+#else
+                  AF_INET
+#endif
+                  : AF_INET);
+
+#ifdef WIN32
+    if ( SockAddr_isMulticast( &mSettings->local ) ) {
+        // Multicast on Win32 requires special handling
+        mSettings->mSock = WSASocket( domain, type, 0, 0, 0, WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF );
+        WARN_errno( mSettings->mSock == INVALID_SOCKET, "socket" );
+
+    } else
+#endif
+    {
+        mSettings->mSock = socket( domain, type, 0 );
+        WARN_errno( mSettings->mSock == INVALID_SOCKET, "socket" );
+    } 
+
+    SetSocketOptions( mSettings );
+
+    // reuse the address, so we can run if a former server was killed off
+    int boolean = 1;
+    Socklen_t len = sizeof(boolean);
+    setsockopt( mSettings->mSock, SOL_SOCKET, SO_REUSEADDR, (char*) &boolean, len );
+
+    // bind socket to server address
+#ifdef WIN32
+    if ( SockAddr_isMulticast( &mSettings->local ) ) {
+        // Multicast on Win32 requires special handling
+        rc = WSAJoinLeaf( mSettings->mSock, (sockaddr*) &mSettings->local, mSettings->size_local,0,0,0,0,JL_BOTH);
+        WARN_errno( rc == SOCKET_ERROR, "WSAJoinLeaf (aka bind)" );
+    } else
+#endif
+    {
+        rc = bind( mSettings->mSock, (sockaddr*) &mSettings->local, mSettings->size_local );
+        FAIL_errno( rc == SOCKET_ERROR, "bind", mSettings );
+    }
+    // listen for connections (TCP only).
+    // default backlog traditionally 5
+    if ( !isUDP( mSettings ) ) {
+        rc = listen( mSettings->mSock, 5 );
+        WARN_errno( rc == SOCKET_ERROR, "listen" );
+    }
+
+#ifndef WIN32
+    // if multicast, join the group
+    if ( SockAddr_isMulticast( &mSettings->local ) ) {
+        McastJoin( );
+    }
+#endif
+} // end Listen
+
+/* -------------------------------------------------------------------
+ * Joins the multicast group, with the default interface.
+ * ------------------------------------------------------------------- */
+
+void Listener::McastJoin( ) {
+#ifdef HAVE_MULTICAST
+    if ( !SockAddr_isIPv6( &mSettings->local ) ) {
+        struct ip_mreq mreq;
+
+        memcpy( &mreq.imr_multiaddr, SockAddr_get_in_addr( &mSettings->local ), 
+                sizeof(mreq.imr_multiaddr));
+
+        mreq.imr_interface.s_addr = htonl( INADDR_ANY );
+
+        int rc = setsockopt( mSettings->mSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
+                             (char*) &mreq, sizeof(mreq));
+        WARN_errno( rc == SOCKET_ERROR, "multicast join" );
+    }
+#ifdef HAVE_IPV6_MULTICAST
+      else {
+        struct ipv6_mreq mreq;
+
+        memcpy( &mreq.ipv6mr_multiaddr, SockAddr_get_in6_addr( &mSettings->local ), 
+                sizeof(mreq.ipv6mr_multiaddr));
+
+        mreq.ipv6mr_interface = 0;
+
+        int rc = setsockopt( mSettings->mSock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,
+                             (char*) &mreq, sizeof(mreq));
+        WARN_errno( rc == SOCKET_ERROR, "multicast join" );
+    }
+#endif
+#endif
+}
+// end McastJoin
+
+/* -------------------------------------------------------------------
+ * Sets the Multicast TTL for outgoing packets.
+ * ------------------------------------------------------------------- */
+
+void Listener::McastSetTTL( int val ) {
+#ifdef HAVE_MULTICAST
+    if ( !SockAddr_isIPv6( &mSettings->local ) ) {
+        int rc = setsockopt( mSettings->mSock, IPPROTO_IP, IP_MULTICAST_TTL,
+                             (char*) &val, sizeof(val));
+        WARN_errno( rc == SOCKET_ERROR, "multicast ttl" );
+    }
+#ifdef HAVE_IPV6_MULTICAST
+      else {
+        int rc = setsockopt( mSettings->mSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+                             (char*) &val, sizeof(val));
+        WARN_errno( rc == SOCKET_ERROR, "multicast ttl" );
+    }
+#endif
+#endif
+}
+// end McastSetTTL
+
+/* -------------------------------------------------------------------
+ * After Listen() has setup mSock, this will block
+ * until a new connection arrives or until the -t value occurs
+ * ------------------------------------------------------------------- */
+
+void Listener::Accept( thread_Settings *server ) {
+
+    server->size_peer = sizeof(iperf_sockaddr); 
+    // Handles interupted accepts. Returns the newly connected socket.
+    server->mSock = INVALID_SOCKET;
+
+    bool mMode_Time = isServerModeTime( mSettings ) && !isDaemon( mSettings );
+    // setup termination variables
+    if ( mMode_Time ) {
+	mEndTime.setnow();
+	mEndTime.add( mSettings->mAmount / 100.0 );
+	if (!setsock_blocking(mSettings->mSock, 0)) {
+	    WARN(1, "Failed setting socket to non-blocking mode");
+	}
+    }
+
+    while ( server->mSock == INVALID_SOCKET) {
+	if (mMode_Time) {
+	    struct timeval t1;
+	    gettimeofday( &t1, NULL );
+	    if (mEndTime.before( t1)) {
+		break;
+	    }
+	    struct timeval timeout;
+	    timeout.tv_sec = mSettings->mAmount / 100;
+	    timeout.tv_usec = (mSettings->mAmount % 100) * 10000;
+	    fd_set set;
+	    FD_ZERO(&set);
+	    FD_SET(mSettings->mSock, &set);
+	    if (select( mSettings->mSock + 1, &set, NULL, NULL, &timeout) <= 0) {
+		break;
+	    }
+	}
+	if ( isUDP( server ) ) {
+	    /* ------------------------------------------------------------------------
+	     * Do the equivalent of an accept() call for UDP sockets. This waits
+	     * on a listening UDP socket until we get a datagram.
+	     * ------------------------------------------------------------------- ----*/
+	    int rc;
+	    Iperf_ListEntry *exist;
+	    int32_t datagramID;
+	    server->mSock = INVALID_SOCKET;
+
+	    rc = recvfrom( mSettings->mSock, mBuf, mSettings->mBufLen, 0,
+			   (struct sockaddr*) &server->peer, &server->size_peer );
+	    FAIL_errno( rc == SOCKET_ERROR, "recvfrom", mSettings );
+
+	    Mutex_Lock( &clients_mutex );
+    
+	    // Handle connection for UDP sockets.
+	    exist = Iperf_present( &server->peer, clients);
+	    datagramID = ntohl( ((UDP_datagram*) mBuf)->id );
+	    if ( exist == NULL && datagramID >= 0 ) {
+		server->mSock = mSettings->mSock;
+		int rc = connect( server->mSock, (struct sockaddr*) &server->peer,
+				  server->size_peer );
+		FAIL_errno( rc == SOCKET_ERROR, "connect UDP", mSettings );
+	    } else {
+		server->mSock = INVALID_SOCKET;
+	    }
+	    Mutex_Unlock( &clients_mutex );
+	} else {
+	    // accept a TCP  connection
+	    server->mSock = accept( mSettings->mSock,  (sockaddr*) &server->peer, &server->size_peer );
+	    if ( server->mSock == INVALID_SOCKET &&
+#if WIN32
+		 WSAGetLastError() == WSAEINTR
+#else
+		 errno == EINTR
+#endif
+		) {
+		break;
+	    }
+	}
+    }
+    if (server->mSock != INVALID_SOCKET) {
+	if (!setsock_blocking(server->mSock, 1)) {
+	    WARN(1, "Failed setting socket to blocking mode");
+	}
+    }
+    server->size_local = sizeof(iperf_sockaddr); 
+    getsockname( server->mSock, (sockaddr*) &server->local, &server->size_local );
+} // end Accept
+
+void Listener::UDPSingleServer( ) {
+    
+    bool client = false, UDP = isUDP( mSettings ), mCount = (mSettings->mThreads != 0);
+    thread_Settings *tempSettings = NULL;
+    Iperf_ListEntry *exist = NULL;
+    Iperf_ListEntry *listtemp = NULL;
+    int rc;
+    int32_t datagramID;
+    client_hdr* hdr = ( UDP ? (client_hdr*) (((UDP_datagram*)mBuf) + 1) : 
+                              (client_hdr*) mBuf);
+    ReportStruct *reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+    bool mMode_Time = isServerModeTime( mSettings ) && !isDaemon( mSettings );
+    // setup termination variables
+    if ( mMode_Time ) {
+	mEndTime.setnow();
+	mEndTime.add( mSettings->mAmount / 100.0 );
+    }
+
+    if ( mSettings->mHost != NULL ) {
+        client = true;
+        SockAddr_remoteAddr( mSettings );
+    }
+    Settings_Copy( mSettings, &server );
+    DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+    server->mThreadMode = kMode_Server;
+
+
+    // Accept each packet, 
+    // If there is no existing client, then start  
+    // a new report to service the new client 
+    // The listener runs in a single thread 
+    Mutex_Lock( &clients_mutex );
+    do {
+        // Get next packet
+        while ( sInterupted == 0) {
+            server->size_peer = sizeof( iperf_sockaddr );
+
+	    if (mMode_Time) {
+		struct timeval t1;
+		gettimeofday( &t1, NULL );
+		if (mEndTime.before( t1)) {
+		    sInterupted = 1;
+		    break;
+		}
+		struct timeval timeout;
+		timeout.tv_sec = mSettings->mAmount / 100;
+		timeout.tv_usec = (mSettings->mAmount % 100) * 10000;
+		fd_set set;
+		FD_ZERO(&set);
+		FD_SET(mSettings->mSock, &set);
+		if (select( mSettings->mSock + 1, &set, NULL, NULL, &timeout) <= 0) {
+		    sInterupted = 1;
+		    break;
+		}
+	    }
+
+            rc = recvfrom( mSettings->mSock, mBuf, mSettings->mBufLen, 0, 
+                           (struct sockaddr*) &server->peer, &server->size_peer );
+            WARN_errno( rc == SOCKET_ERROR, "recvfrom" );
+            if ( rc == SOCKET_ERROR ) {
+                return;
+            }
+        
+        
+            // Handle connection for UDP sockets.
+            exist = Iperf_present( &server->peer, clients);
+            datagramID = ntohl( ((UDP_datagram*) mBuf)->id ); 
+            if ( datagramID >= 0 ) {
+                if ( exist != NULL ) {
+                    // read the datagram ID and sentTime out of the buffer 
+                    reportstruct->packetID = datagramID; 
+                    reportstruct->sentTime.tv_sec = ntohl( ((UDP_datagram*) mBuf)->tv_sec  );
+                    reportstruct->sentTime.tv_usec = ntohl( ((UDP_datagram*) mBuf)->tv_usec ); 
+        
+                    reportstruct->packetLen = rc;
+                    gettimeofday( &(reportstruct->packetTime), NULL );
+        
+                    ReportPacket( exist->server->reporthdr, reportstruct );
+                } else {
+                    Mutex_Lock( &groupCond );
+                    groupID--;
+                    server->mSock = -groupID;
+                    Mutex_Unlock( &groupCond );
+                    server->size_local = sizeof(iperf_sockaddr); 
+                    getsockname( mSettings->mSock, (sockaddr*) &server->local, 
+                                 &server->size_local );
+                    break;
+                }
+            } else {
+                if ( exist != NULL ) {
+                    // read the datagram ID and sentTime out of the buffer 
+                    reportstruct->packetID = -datagramID; 
+                    reportstruct->sentTime.tv_sec = ntohl( ((UDP_datagram*) mBuf)->tv_sec  );
+                    reportstruct->sentTime.tv_usec = ntohl( ((UDP_datagram*) mBuf)->tv_usec ); 
+        
+                    reportstruct->packetLen = rc;
+                    gettimeofday( &(reportstruct->packetTime), NULL );
+        
+                    ReportPacket( exist->server->reporthdr, reportstruct );
+                    // stop timing 
+                    gettimeofday( &(reportstruct->packetTime), NULL );
+                    CloseReport( exist->server->reporthdr, reportstruct );
+        
+                    if ( rc > (int) ( sizeof( UDP_datagram )
+                                                      + sizeof( server_hdr ) ) ) {
+                        UDP_datagram *UDP_Hdr;
+                        server_hdr *hdr;
+        
+                        UDP_Hdr = (UDP_datagram*) mBuf;
+                        Transfer_Info *stats = GetReport( exist->server->reporthdr );
+                        hdr = (server_hdr*) (UDP_Hdr+1);
+        
+                        hdr->flags        = htonl( HEADER_VERSION1 );
+                        hdr->total_len1   = htonl( (long) (stats->TotalLen >> 32) );
+                        hdr->total_len2   = htonl( (long) (stats->TotalLen & 0xFFFFFFFF) );
+                        hdr->stop_sec     = htonl( (long) stats->endTime );
+                        hdr->stop_usec    = htonl( (long)((stats->endTime - (long)stats->endTime)
+                                                          * rMillion));
+                        hdr->error_cnt    = htonl( stats->cntError );
+                        hdr->outorder_cnt = htonl( stats->cntOutofOrder );
+                        hdr->datagrams    = htonl( stats->cntDatagrams );
+                        hdr->jitter1      = htonl( (long) stats->jitter );
+                        hdr->jitter2      = htonl( (long) ((stats->jitter - (long)stats->jitter) 
+                                                           * rMillion) );
+        
+                    }
+                    EndReport( exist->server->reporthdr );
+                    exist->server->reporthdr = NULL;
+                    if (clients == NULL) {
+                        DEBUGP("%s[%d]: Iperf_delete: %p\n", __FILE__, (int)__LINE__, clients);
+                        Iperf_delete( &(exist->server->peer), &clients );
+                        clients = NULL;
+                    }
+                } else if ( rc > (int) ( sizeof( UDP_datagram )
+                                                  + sizeof( server_hdr ) ) ) {
+                    UDP_datagram *UDP_Hdr;
+                    server_hdr *hdr;
+        
+                    UDP_Hdr = (UDP_datagram*) mBuf;
+                    hdr = (server_hdr*) (UDP_Hdr+1);
+                    hdr->flags = htonl( 0 );
+                }
+                sendto( mSettings->mSock, mBuf, mSettings->mBufLen, 0,
+                        (struct sockaddr*) &server->peer, server->size_peer);
+            }
+        }
+        if ( server->mSock == INVALID_SOCKET ) {
+            break;
+        }
+        if ( sInterupted != 0 ) {
+            close( server->mSock );
+            break;
+        }
+        // Reset Single Client Stuff
+        if ( isSingleClient( mSettings ) && clients == NULL ) {
+            mSettings->peer = server->peer;
+            mClients--;
+            client = true;
+            // Once all the server threads exit then quit
+            // Must keep going in case this client sends
+            // more streams
+            if ( mClients == 0 ) {
+                thread_release_nonterm( 0 );
+                mClients = 1;
+            }
+        }
+        // Verify that it is allowed
+        if ( client ) {
+            if ( !SockAddr_Hostare_Equal( (sockaddr*) &mSettings->peer, 
+                                          (sockaddr*) &server->peer ) ) {
+                // Not allowed try again
+                connect( mSettings->mSock, 
+                         (sockaddr*) &server->peer, 
+                         server->size_peer );
+                close( mSettings->mSock );
+                mSettings->mSock = -1; 
+                Listen( );
+                continue;
+            }
+        }
+
+        // Create an entry for the connection list
+        listtemp = new Iperf_ListEntry;
+        DEBUGP("%s[%d]: new Iperf_ListEntry: %p\n", __FILE__, (int)__LINE__, listtemp);
+        memcpy(listtemp, &server->peer, sizeof(iperf_sockaddr));
+        listtemp->server = server;
+        listtemp->next = NULL;
+
+        // See if we need to do summing
+        exist = Iperf_hostpresent( &server->peer, clients); 
+
+        if ( exist != NULL ) {
+            // Copy group ID
+            listtemp->holder = exist->holder;
+            server->multihdr = exist->holder;
+        } else {
+            server->mThreads = 0;
+            Mutex_Lock( &groupCond );
+            groupID--;
+            listtemp->holder = InitMulti( server, groupID );
+            DEBUGP("%s[%d]: InitMulti: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+            server->multihdr = listtemp->holder;
+            Mutex_Unlock( &groupCond );
+        }
+
+        // Store entry in connection list
+        Iperf_pushback( listtemp, &clients ); 
+
+        tempSettings = NULL;
+        if ( !isCompat( mSettings ) && !isMulticast( mSettings ) ) {
+            Settings_GenerateClientSettings( server, &tempSettings, 
+                                              hdr );
+        }
+
+
+        if ( tempSettings != NULL ) {
+            client_init( tempSettings );
+            if ( tempSettings->mMode == kTest_DualTest ) {
+#ifdef HAVE_THREAD
+                thread_start( tempSettings );
+#else
+                server->runNext = tempSettings;
+#endif
+            } else {
+                server->runNext =  tempSettings;
+            }
+        }
+        server->reporthdr = InitReport( server );
+
+        // Prep for next connection
+        if ( !isSingleClient( mSettings ) ) {
+            mClients--;
+        }
+
+        /*
+        if (server != NULL) {
+            DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+            Settings_Destroy( server );
+            server = NULL;
+        }
+        */
+
+        Settings_Copy( mSettings, &server );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, server);
+
+        server->mThreadMode = kMode_Server;
+
+        if ((listtemp != NULL) && (listtemp->holder != NULL)) {
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, listtemp->holder);
+            free(listtemp->holder);
+            listtemp->holder = NULL;
+        }
+
+    } while ( !sInterupted && (!mCount || ( mCount && mClients > 0 )) );
+    Mutex_Unlock( &clients_mutex );
+
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR(reportstruct);
+        reportstruct = NULL;
+    }
+
+    if (server != NULL) {
+        DEBUGP("%s[%d]: Settings_Destroy: %p\n", __FILE__, (int)__LINE__, server);
+        Settings_Destroy( server );
+        server = NULL;
+    }
+
+}
+
+
diff -uprN iperf-2.0.9.orig/src/Locale.c iperf-2.0.9/src/Locale.c
--- iperf-2.0.9.orig/src/Locale.c	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Locale.c	2017-02-12 21:27:00.005840003 +0900
@@ -154,34 +154,34 @@ const char separator_line[] =
 "------------------------------------------------------------\n";
 
 const char server_port[] =
-"Server listening on %s port %d\n";
+"Server listening on %s port %u\n";
 
 const char client_port[] =
-"Client connecting to %s, %s port %d\n";
+"Client connecting to %s, %s port %u\n";
 
 const char server_pid_port[] =
-"Server listening on %s port %d with pid %d\n";
+"Server listening on %s port %u with pid %u\n";
 
 const char client_pid_port[] =
-"Client connecting to %s, %s port %d with pid %d\n";
+"Client connecting to %s, %s port %u with pid %u\n";
 
 const char bind_address[] =
 "Binding to local address %s\n";
 
 const char multicast_ttl[] =
-"Setting multicast TTL to %d\n";
+"Setting multicast TTL to %u\n";
 
 const char join_multicast[] =
 "Joining multicast group  %s\n";
 
 const char client_datagram_size[] =
-"Sending %d byte datagrams, IPG target: %4.2f us\n";
+"Sending %u byte datagrams, IPG target: %4.2f us\n";
 
 const char client_datagram_size_kalman[] =
-"Sending %d byte datagrams, IPG target: %4.2f us (kalman adjust)\n";
+"Sending %u byte datagrams, IPG target: %4.2f us (kalman adjust)\n";
 
 const char server_datagram_size[] =
-"Receiving %d byte datagrams\n";
+"Receiving %u byte datagrams\n";
 
 const char tcp_window_size[] =
 "TCP window size";
@@ -230,30 +230,30 @@ const char report_bw_read_enhanced_heade
 "[ ID] Interval        Transfer    Bandwidth       Reads   Dist(bin=%.1fK)\n";
 
 const char report_bw_read_enhanced_format[] =
-"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %d    %d:%d:%d:%d:%d:%d:%d:%d\n";
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u    %u:%u:%u:%u:%u:%u:%u:%u\n";
 
 const char report_sum_bw_read_enhanced_format[] =
-"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %d    %d:%d:%d:%d:%d:%d:%d:%d\n";
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u    %u:%u:%u:%u:%u:%u:%u:%u\n";
 
 #ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
 const char report_bw_write_enhanced_header[] =
 "[ ID] Interval        Transfer    Bandwidth       Write/Err  Rtry    Cwnd/RTT\n";
 
 const char report_bw_write_enhanced_format[] =
-"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %d/%d %10d %8dK/%u us\n";
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u %10d %8dK/%u us\n";
 
 const char report_sum_bw_write_enhanced_format[] =
-"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %d/%d%10d\n";
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u%10d\n";
 
 #else
 const char report_bw_write_enhanced_header[] =
 "[ ID] Interval        Transfer    Bandwidth       Write/Err\n";
 
 const char report_bw_write_enhanced_format[] =
-"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %d/%d\n";
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u\n";
 
 const char report_sum_bw_write_enhanced_format[] =
-"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %d/%d\n";
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u\n";
 #endif
 
 const char report_bw_pps_enhanced_header[] =
@@ -282,10 +282,10 @@ const char report_bw_jitter_loss_suppres
  * Misc reports
  * ------------------------------------------------------------------- */
 const char report_outoforder[] =
-"[%3d] %4.2f-%4.2f sec  %d datagrams received out-of-order\n";
+"[%3d] %4.2f-%4.2f sec  %u datagrams received out-of-order\n";
 
 const char report_sum_outoforder[] =
-"[SUM] %4.2f-%4.2f sec  %d datagrams received out-of-order\n";
+"[SUM] %4.2f-%4.2f sec  %u datagrams received out-of-order\n";
 
 const char report_peer[] =
 "[%3d] local %s port %u connected with %s port %u\n";
@@ -294,13 +294,13 @@ const char report_mss_unsupported[] =
 "[%3d] MSS and MTU size unknown (TCP_MAXSEG not supported by OS?)\n";
 
 const char report_mss[] =
-"[%3d] MSS size %d bytes (MTU %d bytes, %s)\n";
+"[%3d] MSS size %u bytes (MTU %u bytes, %s)\n";
 
 const char report_datagrams[] =
-"[%3d] Sent %d datagrams\n";
+"[%3d] Sent %u datagrams\n";
 
 const char report_sum_datagrams[] =
-"[SUM] Sent %d datagrams\n";
+"[SUM] Sent %u datagrams\n";
 
 const char server_reporting[] =
 "[%3d] Server Report:\n";
@@ -311,32 +311,36 @@ const char reportCSV_peer[] =
 #ifdef HAVE_QUAD_SUPPORT
 #ifdef HAVE_PRINTF_QD
 const char reportCSV_bw_format[] =
-"%s,%s,%d,%.1f-%.1f,%qd,%qd\n";
+"%s,%s,%u,%.1f-%.1f,%qd,%qd";
 
 const char reportCSV_bw_jitter_loss_format[] =
-"%s,%s,%d,%.1f-%.1f,%qd,%qd,%.3f,%d,%d,%.3f,%d\n";
+"%s,%s,%u,%.1f-%.1f,%qd,%qd,%.3f,%u,%u,%.3f,%u";
 #else // HAVE_PRINTF_QD
 const char reportCSV_bw_format[] =
-"%s,%s,%d,%.1f-%.1f,%lld,%lld\n";
+"%s,%s,%u,%.1f-%.1f,%lld,%lld";
 
 const char reportCSV_bw_jitter_loss_format[] =
-"%s,%s,%d,%.1f-%.1f,%lld,%lld,%.3f,%d,%d,%.3f,%d\n";
+"%s,%s,%u,%.1f-%.1f,%lld,%lld,%.3f,%u,%u,%.3f,%u";
 #endif // HAVE_PRINTF_QD
 #else // HAVE_QUAD_SUPPORT
 #ifdef WIN32
 const char reportCSV_bw_format[] =
-"%s,%s,%d,%.1f-%.1f,%I64d,%I64d\n";
+"%s,%s,%u,%.1f-%.1f,%I64u,%I64u\n";
 
 const char reportCSV_bw_jitter_loss_format[] =
-"%s,%s,%d,%.1f-%.1f,%I64d,%I64d,%.3f,%d,%d,%.3f,%d\n";
+"%s,%s,%u,%.1f-%.1f,%I64u,%I64u,%.3f,%u,%u,%.3f,%u\n";
 #else
 const char reportCSV_bw_format[] =
-"%s,%s,%d,%.1f-%.1f,%d,%d\n";
+"%s,%s,%u,%.1f-%.1f,%u,%u\n";
 
 const char reportCSV_bw_jitter_loss_format[] =
-"%s,%s,%d,%.1f-%.1f,%d,%d,%.3f,%d,%d,%.3f,%d\n";
+"%s,%s,%u,%.1f-%.1f,%u,%u,%.3f,%u,%u,%.3f,%u\n";
 #endif //WIN32
 #endif //HAVE_QUAD_SUPPORT
+
+const char reportCSV_bw_cpu[] =
+",%f,%f,%f";
+
 /* -------------------------------------------------------------------
  * warnings
  * ------------------------------------------------------------------- */
@@ -345,7 +349,7 @@ const char warn_window_requested[] =
 " (WARNING: requested %s)";
 
 const char warn_window_small[] = "\
-WARNING: TCP window size set to %d bytes. A small window size\n\
+WARNING: TCP window size set to %u bytes. A small window size\n\
 will give poor performance. See the Iperf documentation.\n";
 
 const char warn_delay_large[] =
@@ -355,10 +359,10 @@ const char warn_no_pathmtu[] =
 "WARNING: Path MTU Discovery may not be enabled.\n";
 
 const char warn_no_ack[]=
-"[%3d] WARNING: did not receive ack of last datagram after %d tries.\n";
+"[%3d] WARNING: did not receive ack of last datagram after %u tries.\n";
 
 const char warn_ack_failed[]=
-"[%3d] WARNING: ack of last datagram failed after %d tries.\n";
+"[%3d] WARNING: ack of last datagram failed after %u tries.\n";
 
 const char warn_fileopen_failed[]=
 "WARNING: Unable to open file stream for transfer\n\
@@ -389,7 +393,7 @@ const char warn_implied_compatibility[]
 "WARNING: option -%c has implied compatibility mode\n";
 
 const char warn_buffer_too_small[] =
-"WARNING: the UDP buffer was increased to %d for proper operation\n";
+"WARNING: the UDP buffer was increased to %u for proper operation\n";
 
 const char warn_invalid_single_threaded[] =
 "WARNING: option -%c is not valid in single threaded versions\n";
diff -uprN iperf-2.0.9.orig/src/Locale.c.~1~ iperf-2.0.9/src/Locale.c.~1~
--- iperf-2.0.9.orig/src/Locale.c.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Locale.c.~1~	2017-02-11 02:06:37.190429094 +0900
@@ -0,0 +1,409 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Locale.c
+ * by Ajay Tirumala <tirumala@ncsa.uiuc.edu>
+ * & Mark Gates <mgates@nlanr.net>
+ * -------------------------------------------------------------------
+ * Strings and other stuff that is locale specific.
+ * ------------------------------------------------------------------- */
+#include "version.h"
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#ifdef WIN32
+#include "config.win32.h"
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* -------------------------------------------------------------------
+ * usage
+ * ------------------------------------------------------------------- */
+
+const char usage_short[] = "\
+Usage: %s [-s|-c host] [options]\n\
+Try `%s --help' for more information.\n";
+
+const char usage_long1[] = "\
+Usage: iperf [-s|-c host] [options]\n\
+       iperf [-h|--help] [-v|--version]\n\
+\n\
+Client/Server:\n\
+  -b, --bandwidth #[KMG | pps]  bandwidth to send at in bits/sec or packets per second\n\
+  -e, --enhancedreports    use enhanced reporting giving more tcp/udp and traffic information\n\
+  -f, --format    [kmKM]   format to report: Kbits, Mbits, KBytes, MBytes\n\
+  -i, --interval  #        seconds between periodic bandwidth reports\n\
+  -l, --len       #[KM]    length of buffer to read or write (default 8 KB)\n\
+  -m, --print_mss          print TCP maximum segment size (MTU - TCP/IP header)\n\
+  -o, --output    <filename> output the report or error message to this specified file\n\
+  -p, --port      #        server port to listen on/connect to\n\
+  -u, --udp                use UDP rather than TCP\n\
+  -w, --window    #[KM]    TCP window size (socket buffer size)\n"
+#ifdef HAVE_SCHED_SETSCHEDULER
+"  -z, --realtime           request realtime scheduler\n"
+#endif
+"  -B, --bind      <host>   bind to <host>, an interface or multicast address\n\
+  -C, --compatibility      for use with older versions does not sent extra msgs\n\
+  -M, --mss       #        set TCP maximum segment size (MTU - 40 bytes)\n\
+  -N, --nodelay            set TCP no delay, disabling Nagle's Algorithm\n\
+  -V, --ipv6_domain        Set the domain to IPv6\n\
+\n\
+Server specific:\n\
+  -s, --server             run in server mode\n\
+  -U, --single_udp         run in single threaded UDP mode\n\
+  -D, --daemon             run the server as a daemon\n"
+#ifdef WIN32
+"  -R, --remove             remove service in win32\n"
+#endif
+;
+
+const char usage_long2[] = "\
+\n\
+Client specific:\n\
+  -c, --client    <host>   run in client mode, connecting to <host>\n\
+  -d, --dualtest           Do a bidirectional test simultaneously\n\
+  -n, --num       #[KM]    number of bytes to transmit (instead of -t)\n\
+  -r, --tradeoff           Do a bidirectional test individually\n\
+  -t, --time      #        time in seconds to transmit for (default 10 secs)\n\
+  -B, --bind [<ip> | <ip:port>] bind src addr(s) from which to originate traffic\n\
+  -F, --fileinput <name>   input the data to be transmitted from a file\n\
+  -I, --stdin              input the data to be transmitted from stdin\n\
+  -L, --listenport #       port to receive bidirectional tests back on\n\
+  -P, --parallel  #        number of parallel client threads to run\n\
+  -T, --ttl       #        time-to-live, for multicast (default 1)\n\
+  -Z, --linux-congestion <algo>  set TCP congestion control algorithm (Linux only)\n\
+\n\
+Miscellaneous:\n\
+  -x, --reportexclude [CDMSV]   exclude C(connection) D(data) M(multicast) S(settings) V(server) reports\n\
+  -y, --reportstyle C      report as a Comma-Separated Values\n\
+  -h, --help               print this message and quit\n\
+  -v, --version            print version information and quit\n\
+\n\
+[KM] Indicates options that support a K or M suffix for kilo- or mega-\n\
+\n\
+The TCP window size option can be set by the environment variable\n\
+TCP_WINDOW_SIZE. Most other options can be set by an environment variable\n\
+IPERF_<long option name>, such as IPERF_BANDWIDTH.\n\
+\n\
+Source at <http://sourceforge.net/projects/iperf2/>\n\
+Report bugs to <iperf-users@lists.sourceforge.net>\n";
+
+// include a description of the threading in the version
+#if   defined( HAVE_POSIX_THREAD )
+    #define IPERF_THREADS "pthreads"
+#elif defined( HAVE_WIN32_THREAD )
+    #define IPERF_THREADS "win32 threads"
+#else
+    #define IPERF_THREADS "single threaded"
+#endif
+
+const char version[] =
+"iperf version " IPERF_VERSION " (" IPERF_VERSION_DATE ") " IPERF_THREADS "\n";
+
+/* -------------------------------------------------------------------
+ * settings
+ * ------------------------------------------------------------------- */
+
+const char separator_line[] =
+"------------------------------------------------------------\n";
+
+const char server_port[] =
+"Server listening on %s port %u\n";
+
+const char client_port[] =
+"Client connecting to %s, %s port %u\n";
+
+const char server_pid_port[] =
+"Server listening on %s port %u with pid %u\n";
+
+const char client_pid_port[] =
+"Client connecting to %s, %s port %u with pid %u\n";
+
+const char bind_address[] =
+"Binding to local address %s\n";
+
+const char multicast_ttl[] =
+"Setting multicast TTL to %u\n";
+
+const char join_multicast[] =
+"Joining multicast group  %s\n";
+
+const char client_datagram_size[] =
+"Sending %u byte datagrams, IPG target: %4.2f us\n";
+
+const char client_datagram_size_kalman[] =
+"Sending %u byte datagrams, IPG target: %4.2f us (kalman adjust)\n";
+
+const char server_datagram_size[] =
+"Receiving %u byte datagrams\n";
+
+const char tcp_window_size[] =
+"TCP window size";
+
+const char udp_buffer_size[] =
+"UDP buffer size";
+
+const char window_default[] =
+"(default)";
+
+const char wait_server_threads[] =
+"Waiting for server threads to complete. Interrupt again to force quit.\n";
+
+/* -------------------------------------------------------------------
+ * Legacy reports
+ * ------------------------------------------------------------------- */
+
+const char report_bw_header[] =
+"[ ID] Interval       Transfer     Bandwidth\n";
+
+const char report_bw_format[] =
+"[%3d] %4.1f-%4.1f sec  %ss  %ss/sec\n";
+
+const char report_sum_bw_format[] =
+"[SUM] %4.1f-%4.1f sec  %ss  %ss/sec\n";
+
+const char report_bw_jitter_loss_header[] =
+"[ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams\n";
+const char report_bw_jitter_loss_format[] =
+"[%3d] %4.1f-%4.1f sec  %ss  %ss/sec  %6.3f ms %4d/%5d (%.2g%%)\n";
+
+const char report_sum_bw_jitter_loss_format[] =
+"[SUM] %4.1f-%4.1f sec  %ss  %ss/sec  %6.3f ms %4d/%5d (%.2g%%)\n";
+
+/* -------------------------------------------------------------------
+ * Enhanced reports (per -e)
+ * ------------------------------------------------------------------- */
+
+const char report_bw_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec\n";
+
+const char report_sum_bw_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec\n";
+
+const char report_bw_read_enhanced_header[] =
+"[ ID] Interval        Transfer    Bandwidth       Reads   Dist(bin=%.1fK)\n";
+
+const char report_bw_read_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u    %u:%u:%u:%u:%u:%u:%u:%u\n";
+
+const char report_sum_bw_read_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u    %u:%u:%u:%u:%u:%u:%u:%u\n";
+
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+const char report_bw_write_enhanced_header[] =
+"[ ID] Interval        Transfer    Bandwidth       Write/Err  Rtry    Cwnd/RTT\n";
+
+const char report_bw_write_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u %10d %8dK/%u us\n";
+
+const char report_sum_bw_write_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u%10d\n";
+
+#else
+const char report_bw_write_enhanced_header[] =
+"[ ID] Interval        Transfer    Bandwidth       Write/Err\n";
+
+const char report_bw_write_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u\n";
+
+const char report_sum_bw_write_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %u/%u\n";
+#endif
+
+const char report_bw_pps_enhanced_header[] =
+"[ ID] Interval       Transfer     Bandwidth      PPS\n";
+
+const char report_bw_pps_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec %4.0f pps\n";
+
+const char report_sum_bw_pps_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec %4.0f pps\n";
+
+const char report_bw_jitter_loss_enhanced_header[] =
+"[ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total \
+ Latency avg/min/max/stdev PPS\n";
+
+const char report_bw_jitter_loss_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %6.3f ms %4d/%5d (%.2g%%) %6.3f/%6.3f/%6.3f/%6.3f ms %4.0f pps\n";
+
+const char report_sum_bw_jitter_loss_enhanced_format[] =
+"[SUM] %4.2f-%4.2f sec  %ss  %ss/sec  %6.3f ms %4d/%5d (%.2g%%)  %4.0f pps\n";
+
+const char report_bw_jitter_loss_suppress_enhanced_format[] =
+"[%3d] %4.2f-%4.2f sec  %ss  %ss/sec  %6.3f ms %4d/%5d (%.2g%%) -/-/-/- ms %4.0f pps\n";
+
+/* -------------------------------------------------------------------
+ * Misc reports
+ * ------------------------------------------------------------------- */
+const char report_outoforder[] =
+"[%3d] %4.2f-%4.2f sec  %u datagrams received out-of-order\n";
+
+const char report_sum_outoforder[] =
+"[SUM] %4.2f-%4.2f sec  %u datagrams received out-of-order\n";
+
+const char report_peer[] =
+"[%3d] local %s port %u connected with %s port %u\n";
+
+const char report_mss_unsupported[] =
+"[%3d] MSS and MTU size unknown (TCP_MAXSEG not supported by OS?)\n";
+
+const char report_mss[] =
+"[%3d] MSS size %u bytes (MTU %u bytes, %s)\n";
+
+const char report_datagrams[] =
+"[%3d] Sent %u datagrams\n";
+
+const char report_sum_datagrams[] =
+"[SUM] Sent %u datagrams\n";
+
+const char server_reporting[] =
+"[%3d] Server Report:\n";
+
+const char reportCSV_peer[] =
+"%s,%u,%s,%u";
+
+#ifdef HAVE_QUAD_SUPPORT
+#ifdef HAVE_PRINTF_QD
+const char reportCSV_bw_format[] =
+"%s,%s,%u,%.1f-%.1f,%qd,%qd";
+
+const char reportCSV_bw_jitter_loss_format[] =
+"%s,%s,%u,%.1f-%.1f,%qd,%qd,%.3f,%u,%u,%.3f,%u";
+#else // HAVE_PRINTF_QD
+const char reportCSV_bw_format[] =
+"%s,%s,%u,%.1f-%.1f,%lld,%lld";
+
+const char reportCSV_bw_jitter_loss_format[] =
+"%s,%s,%u,%.1f-%.1f,%lld,%lld,%.3f,%u,%u,%.3f,%u";
+#endif // HAVE_PRINTF_QD
+#else // HAVE_QUAD_SUPPORT
+#ifdef WIN32
+const char reportCSV_bw_format[] =
+"%s,%s,%u,%.1f-%.1f,%I64u,%I64u\n";
+
+const char reportCSV_bw_jitter_loss_format[] =
+"%s,%s,%u,%.1f-%.1f,%I64u,%I64u,%.3f,%u,%u,%.3f,%u\n";
+#else
+const char reportCSV_bw_format[] =
+"%s,%s,%u,%.1f-%.1f,%u,%u\n";
+
+const char reportCSV_bw_jitter_loss_format[] =
+"%s,%s,%u,%.1f-%.1f,%u,%u,%.3f,%u,%u,%.3f,%u\n";
+#endif //WIN32
+#endif //HAVE_QUAD_SUPPORT
+
+const char reportCSV_bw_cpu[] =
+",%.1f,%.1f,%.1f";
+
+/* -------------------------------------------------------------------
+ * warnings
+ * ------------------------------------------------------------------- */
+
+const char warn_window_requested[] =
+" (WARNING: requested %s)";
+
+const char warn_window_small[] = "\
+WARNING: TCP window size set to %u bytes. A small window size\n\
+will give poor performance. See the Iperf documentation.\n";
+
+const char warn_delay_large[] =
+"WARNING: delay too large, reducing from %.1f to 1.0 seconds.\n";
+
+const char warn_no_pathmtu[] =
+"WARNING: Path MTU Discovery may not be enabled.\n";
+
+const char warn_no_ack[]=
+"[%3d] WARNING: did not receive ack of last datagram after %u tries.\n";
+
+const char warn_ack_failed[]=
+"[%3d] WARNING: ack of last datagram failed after %u tries.\n";
+
+const char warn_fileopen_failed[]=
+"WARNING: Unable to open file stream for transfer\n\
+Using default data stream. \n";
+
+const char unable_to_change_win[]=
+"WARNING: Unable to change the window size\n";
+
+const char opt_estimate[]=
+"Optimal Estimate\n";
+
+const char report_interval_small[] =
+"WARNING: interval too small, increasing from %3.3f to 5 milliseconds.\n";
+
+const char warn_invalid_server_option[] =
+"WARNING: option -%c is not valid for server mode\n";
+
+const char warn_invalid_client_option[] =
+"WARNING: option -%c is not valid for client mode\n";
+
+const char warn_invalid_compatibility_option[] =
+"WARNING: option -%c is not valid in compatibility mode\n";
+
+const char warn_implied_udp[] =
+"WARNING: option -%c implies udp testing\n";
+
+const char warn_implied_compatibility[] =
+"WARNING: option -%c has implied compatibility mode\n";
+
+const char warn_buffer_too_small[] =
+"WARNING: the UDP buffer was increased to %u for proper operation\n";
+
+const char warn_invalid_single_threaded[] =
+"WARNING: option -%c is not valid in single threaded versions\n";
+
+const char warn_invalid_report_style[] =
+"WARNING: unknown reporting style \"%s\", switching to default\n";
+
+const char warn_invalid_report[] =
+"WARNING: unknown reporting type \"%c\", ignored\n valid options are:\n\t exclude: C(connection) D(data) M(multicast) S(settings) V(server) report\n\n";
+
+#ifdef __cplusplus
+} /* end extern "C" */
+#endif
diff -uprN iperf-2.0.9.orig/src/ReportCSV.c iperf-2.0.9/src/ReportCSV.c
--- iperf-2.0.9.orig/src/ReportCSV.c	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/ReportCSV.c	2017-02-13 01:06:58.315486478 +0900
@@ -56,8 +56,16 @@
 #include "report_CSV.h"
 #include "Locale.h"
 
- 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+extern uint32_t g_pcpu[4];
+
 void CSV_stats( Transfer_Info *stats ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     // $TIMESTAMP,$ID,$INTERVAL,$BYTE,$SPEED,$JITTER,$LOSS,$PACKET,$%LOSS
     max_size_t speed = (max_size_t)(((double)stats->TotalLen * 8.0) / (stats->endTime - stats->startTime));
     char timestamp[80];
@@ -90,6 +98,19 @@ void CSV_stats( Transfer_Info *stats ) {
                 stats->endTime, 
                 stats->TotalLen, 
                 speed);
+
+        /*
+        double total = (((double)stats->pcpu[0] * 1000000.0 / CLOCKS_PER_SEC) / (double)stats->pcpu[1]) * 100;
+        double user = ((double)stats->pcpu[2] / (double)stats->pcpu[1]) * 100;
+        double sys = ((double)stats->pcpu[3] / (double)stats->pcpu[1]) * 100;
+        */
+        double total = (((double)g_pcpu[0] * 1000000.0 / CLOCKS_PER_SEC) / (double)g_pcpu[1]) * 100;
+        double user = ((double)g_pcpu[2] / (double)g_pcpu[1]) * 100;
+        double sys = ((double)g_pcpu[3] / (double)g_pcpu[1]) * 100;
+
+        printf( reportCSV_bw_cpu, user, sys, total);
+        printf("\n");
+
     } else {
         // UDP Reporting
         printf( reportCSV_bw_jitter_loss_format, 
@@ -104,9 +125,18 @@ void CSV_stats( Transfer_Info *stats ) {
                 stats->cntError, 
                 stats->cntDatagrams,
                 (100.0 * stats->cntError) / stats->cntDatagrams, stats->cntOutofOrder );
+
+        double total = (((double)stats->pcpu[0] * 1000000.0 / CLOCKS_PER_SEC) / (double)stats->pcpu[1]) * 100;
+        double user = ((double)stats->pcpu[2] / (double)stats->pcpu[1]) * 100;
+        double sys = ((double)stats->pcpu[3] / (double)stats->pcpu[1]) * 100;
+
+        printf( reportCSV_bw_cpu, user, sys, total);
+        printf("\n");
     }
     if ( stats->free == 1 && stats->reserved_delay != NULL ) {
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, stats->reserved_delay);
         free( stats->reserved_delay );
+        stats->reserved_delay = NULL;
     }
 }
 
@@ -116,6 +146,7 @@ void *CSV_peer( Connection_Info *stats,
     char local_addr[ REPORT_ADDRLEN ];
     char remote_addr[ REPORT_ADDRLEN ];
     char *buf = malloc( REPORT_ADDRLEN*2 + 10 );
+    DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, buf);
     struct sockaddr *local = ((struct sockaddr*)&stats->local);
     struct sockaddr *peer = ((struct sockaddr*)&stats->peer);
 
diff -uprN iperf-2.0.9.orig/src/ReportCSV.c.~1~ iperf-2.0.9/src/ReportCSV.c.~1~
--- iperf-2.0.9.orig/src/ReportCSV.c.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/ReportCSV.c.~1~	2017-02-11 02:06:37.194429113 +0900
@@ -0,0 +1,190 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * ReportCSV.c
+ * by Kevin Gibbs <kgibbs@nlanr.net>
+ *
+ * ________________________________________________________________ */
+
+#include "headers.h"
+#include "Settings.hpp"
+#include "util.h"
+#include "Reporter.h"
+#include "report_CSV.h"
+#include "Locale.h"
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+ 
+void CSV_stats( Transfer_Info *stats ) {
+    // $TIMESTAMP,$ID,$INTERVAL,$BYTE,$SPEED,$JITTER,$LOSS,$PACKET,$%LOSS
+    max_size_t speed = (max_size_t)(((double)stats->TotalLen * 8.0) / (stats->endTime - stats->startTime));
+    char timestamp[80];
+    int milliseconds;
+#ifdef HAVE_CLOCK_GETTIME
+    struct timespec t1;
+    clock_gettime(CLOCK_REALTIME, &t1);
+    milliseconds = t1.tv_nsec / 1e6;
+#else
+    struct timeval t1;
+    gettimeofday( &t1, NULL );
+    milliseconds = t1.tv_usec / 1e3;
+#endif
+
+   // localtime is not thread safe.  It's only used by the reporter thread.  Use localtime_r if thread safe is ever needed.
+    if (!stats->mEnhanced) {
+	strftime(timestamp, 80, "%Y%m%d%H%M%S", localtime(&t1.tv_sec));
+    } else {
+	char  buffer[80];
+	strftime(buffer, 80, "%Y%m%d%H%M%S", localtime(&t1.tv_sec));
+	snprintf(timestamp, 80, "%s.%.3d", buffer, milliseconds);
+    }
+    if ( stats->mUDP != (char)kMode_Server ) {
+        // TCP Reporting
+        printf( reportCSV_bw_format, 
+                timestamp, 
+                (stats->reserved_delay == NULL ? ",,," : stats->reserved_delay),
+                stats->transferID, 
+                stats->startTime, 
+                stats->endTime, 
+                stats->TotalLen, 
+                speed);
+
+        double total = (((double)stats->pcpu[0] * 1000000.0 / CLOCKS_PER_SEC) / (double)stats->pcpu[1]) * 100;
+        double user = ((double)stats->pcpu[2] / (double)stats->pcpu[1]) * 100;
+        double sys = ((double)stats->pcpu[3] / (double)stats->pcpu[1]) * 100;
+
+        printf( reportCSV_bw_cpu, user, sys, total);
+        printf("\n");
+
+    } else {
+        // UDP Reporting
+        printf( reportCSV_bw_jitter_loss_format, 
+                timestamp, 
+                (stats->reserved_delay == NULL ? ",,," : stats->reserved_delay),
+                stats->transferID, 
+                stats->startTime, 
+                stats->endTime, 
+                stats->TotalLen, 
+                speed,
+                stats->jitter*1000.0, 
+                stats->cntError, 
+                stats->cntDatagrams,
+                (100.0 * stats->cntError) / stats->cntDatagrams, stats->cntOutofOrder );
+
+        double total = (((double)stats->pcpu[0] * 1000000.0 / CLOCKS_PER_SEC) / (double)stats->pcpu[1]) * 100;
+        double user = ((double)stats->pcpu[2] / (double)stats->pcpu[1]) * 100;
+        double sys = ((double)stats->pcpu[3] / (double)stats->pcpu[1]) * 100;
+
+        printf( reportCSV_bw_cpu, user, sys, total);
+        printf("\n");
+    }
+    if ( stats->free == 1 && stats->reserved_delay != NULL ) {
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, stats->reserved_delay);
+        free( stats->reserved_delay );
+        stats->reserved_delay = NULL;
+    }
+}
+
+void *CSV_peer( Connection_Info *stats, int ID ) {
+    
+    // copy the inet_ntop into temp buffers, to avoid overwriting
+    char local_addr[ REPORT_ADDRLEN ];
+    char remote_addr[ REPORT_ADDRLEN ];
+    char *buf = malloc( REPORT_ADDRLEN*2 + 10 );
+    DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, buf);
+    struct sockaddr *local = ((struct sockaddr*)&stats->local);
+    struct sockaddr *peer = ((struct sockaddr*)&stats->peer);
+
+    if ( local->sa_family == AF_INET ) {
+        inet_ntop( AF_INET, &((struct sockaddr_in*)local)->sin_addr, 
+                   local_addr, REPORT_ADDRLEN);
+    }
+#ifdef HAVE_IPV6
+      else {
+        inet_ntop( AF_INET6, &((struct sockaddr_in6*)local)->sin6_addr, 
+                   local_addr, REPORT_ADDRLEN);
+    }
+#endif
+
+    if ( peer->sa_family == AF_INET ) {
+        inet_ntop( AF_INET, &((struct sockaddr_in*)peer)->sin_addr, 
+                   remote_addr, REPORT_ADDRLEN);
+    }
+#ifdef HAVE_IPV6
+      else {
+        inet_ntop( AF_INET6, &((struct sockaddr_in6*)peer)->sin6_addr, 
+                   remote_addr, REPORT_ADDRLEN);
+    }
+#endif
+
+    snprintf(buf, REPORT_ADDRLEN*2+10, reportCSV_peer, 
+             local_addr, ( local->sa_family == AF_INET ?
+                          ntohs(((struct sockaddr_in*)local)->sin_port) :
+#ifdef HAVE_IPV6
+                          ntohs(((struct sockaddr_in6*)local)->sin6_port)),
+#else
+                          0),
+#endif
+            remote_addr, ( peer->sa_family == AF_INET ?
+                          ntohs(((struct sockaddr_in*)peer)->sin_port) :
+#ifdef HAVE_IPV6
+                          ntohs(((struct sockaddr_in6*)peer)->sin6_port)));
+#else
+                          0));
+#endif
+    return buf;
+}
+
+void CSV_serverstats( Connection_Info *conn, Transfer_Info *stats ) {
+    stats->reserved_delay = CSV_peer( conn, stats->transferID );
+    stats->free = 1;
+    CSV_stats( stats );
+}
+
diff -uprN iperf-2.0.9.orig/src/Reporter.c iperf-2.0.9/src/Reporter.c
--- iperf-2.0.9.orig/src/Reporter.c	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Reporter.c	2017-02-12 22:33:28.330404616 +0900
@@ -63,6 +63,12 @@
 extern "C" {
 #endif
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /*
   The following 4 functions are provided for Reporting
   styles that do not have all the reporting formats. For
@@ -129,8 +135,10 @@ MultiHeader* InitMulti( thread_Settings
         if ( isMultipleReport( agent ) ) {
             multihdr = malloc(sizeof(MultiHeader) +  sizeof(ReporterData) +
                               NUM_MULTI_SLOTS * sizeof(Transfer_Info));
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, multihdr);
         } else {
             multihdr = malloc(sizeof(MultiHeader));
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, multihdr);
         }
         if ( multihdr != NULL ) {
             memset( multihdr, 0, sizeof(MultiHeader) );
@@ -166,6 +174,12 @@ MultiHeader* InitMulti( thread_Settings
                 data->mode = agent->mReportMode;
                 data->info.mFormat = agent->mFormat;
                 data->info.mTTL = agent->mTTL;
+
+                data->info.pcpu[0] = agent->pcpu[0];
+                data->info.pcpu[1] = agent->pcpu[1];
+                data->info.pcpu[2] = agent->pcpu[2];
+                data->info.pcpu[3] = agent->pcpu[3];
+
 		if (data->mThreadMode == kMode_Server) 
 		    data->info.tcp.read.binsize = data->mBufLen / 8;
                 if ( isEnhanced( agent ) ) {
@@ -230,6 +244,7 @@ ReportHeader* InitReport( thread_Setting
          */
         reporthdr = malloc( sizeof(ReportHeader) +
                             NUM_REPORT_STRUCTS * sizeof(ReportStruct) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
         if ( reporthdr != NULL ) {
             // Only need to make sure the headers are clean
             memset( reporthdr, 0, sizeof(ReportHeader));
@@ -255,6 +270,12 @@ ReportHeader* InitReport( thread_Setting
             data->mode = agent->mReportMode;
             data->info.mFormat = agent->mFormat;
             data->info.mTTL = agent->mTTL;
+
+            data->info.pcpu[0] = agent->pcpu[0];
+            data->info.pcpu[1] = agent->pcpu[1];
+            data->info.pcpu[2] = agent->pcpu[2];
+            data->info.pcpu[3] = agent->pcpu[3];
+
 	    if (data->mThreadMode == kMode_Server) 
 		data->info.tcp.read.binsize = data->mBufLen / 8;
             if ( isUDP( agent ) ) {
@@ -278,6 +299,7 @@ ReportHeader* InitReport( thread_Setting
              * Create in one big chunk
              */
             reporthdr = malloc( sizeof(ReportHeader) );
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
             if ( reporthdr != NULL ) {
                 // Only need to make sure the headers are clean
                 memset( reporthdr, 0, sizeof(ReportHeader));
@@ -459,6 +481,7 @@ void ReportSettings( thread_Settings *ag
          * Create in one big chunk
          */
         ReportHeader *reporthdr = malloc( sizeof(ReportHeader) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
     
         if ( reporthdr != NULL ) {
             ReporterData *data = &reporthdr->report;
@@ -485,6 +508,12 @@ void ReportSettings( thread_Settings *ag
             data->connection.size_local = agent->size_local;
             data->mUDPRate = agent->mUDPRate;
             data->mUDPRateUnits = agent->mUDPRateUnits;
+
+            data->info.pcpu[0] = agent->pcpu[0];
+            data->info.pcpu[1] = agent->pcpu[1];
+            data->info.pcpu[2] = agent->pcpu[2];
+            data->info.pcpu[3] = agent->pcpu[3];
+
     #ifdef HAVE_THREAD
             /*
              * Update the ReportRoot to include this report.
@@ -519,6 +548,7 @@ void ReportServerUDP( thread_Settings *a
          * Create in one big chunk
          */
         ReportHeader *reporthdr = malloc( sizeof(ReportHeader) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
         Transfer_Info *stats = &reporthdr->report.info;
 
         if ( reporthdr != NULL ) {
@@ -558,6 +588,15 @@ void ReportServerUDP( thread_Settings *a
             stats->IPGsum = ntohl( server->IPGsum );
 
             stats->mUDP = (char)kMode_Server;
+
+            stats->pcpu[0] = (double)ntohl(server->pcpu[0]);
+            stats->pcpu[1] = (double)ntohl(server->pcpu[1]);
+            stats->pcpu[2] = (double)ntohl(server->pcpu[2]);
+            stats->pcpu[3] = (double)ntohl(server->pcpu[3]);
+            DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+            DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n",
+                   stats->pcpu[0] , stats->pcpu[1] , stats->pcpu[2], stats->pcpu[3]);
+
             reporthdr->report.connection.peer = agent->local;
             reporthdr->report.connection.size_peer = agent->size_local;
             reporthdr->report.connection.local = agent->peer;
@@ -590,6 +629,7 @@ void ReportServerUDP( thread_Settings *a
  * This function is the loop that the reporter thread processes
  */
 void reporter_spawn( thread_Settings *thread ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     do {
         // This section allows for safe exiting with Ctrl-C
         Condition_Lock ( ReportCond );
@@ -624,6 +664,7 @@ again:
                 }
                 // finished with report so free it
                 free( temp );
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, temp);
                 Condition_Unlock ( ReportCond );
                 Condition_Signal( &ReportDoneCond );
                 if (ReportRoot)
@@ -685,7 +726,9 @@ again:
 void process_report ( ReportHeader *report ) {
     if ( report != NULL ) {
         if ( reporter_process_report( report ) ) {
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, report);
             free( report );
+            report = NULL;
         }
     }
 }
@@ -694,6 +737,7 @@ void process_report ( ReportHeader *repo
  * Process reports starting with "reporthdr"
  */
 int reporter_process_report ( ReportHeader *reporthdr ) {
+    //DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     int need_free = 0;
 
     // Recursively process reports
@@ -702,7 +746,9 @@ int reporter_process_report ( ReportHead
             // If we are done with this report then free it
             ReportHeader *temp = reporthdr->next;
             reporthdr->next = reporthdr->next->next;
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, temp);
             free( temp );
+            temp = NULL;
         }
     }
 
@@ -757,6 +803,7 @@ int reporter_process_report ( ReportHead
  * Updates connection stats
  */
 int reporter_handle_packet( ReportHeader *reporthdr ) {
+    //DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     ReportStruct *packet = &reporthdr->data[reporthdr->reporterindex];
     ReporterData *data = &reporthdr->report;
     Transfer_Info *stats = &reporthdr->report.info;
@@ -896,7 +943,9 @@ int reporter_handle_packet( ReportHeader
  * Handles summing of threads
  */
 void reporter_handle_multiple_reports( MultiHeader *reporthdr, Transfer_Info *stats, int force ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     if ( reporthdr != NULL ) {
+        DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
         if ( reporthdr->threads > 1 ) {
             int i;
             Transfer_Info *current = NULL;
@@ -929,6 +978,12 @@ void reporter_handle_multiple_reports( M
 		current->IPGsum = stats->IPGsum;
 		current->mUDP = stats->mUDP;
 		current->mTCP = stats->mTCP;
+
+                current->pcpu[0] = stats->pcpu[0];
+                current->pcpu[1] = stats->pcpu[1];
+                current->pcpu[2] = stats->pcpu[2];
+                current->pcpu[3] = stats->pcpu[3];
+
 		if (stats->mTCP == kMode_Server) {
 		    int ix;
 		    current->tcp.read.cntRead = stats->tcp.read.cntRead;
@@ -984,6 +1039,7 @@ void reporter_handle_multiple_reports( M
 
 #ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
 static void gettcpistats (ReporterData *stats) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
     struct tcp_info tcp_internal;
     socklen_t tcp_info_length = sizeof(struct tcp_info);
     int retry;
@@ -1113,25 +1169,31 @@ int reporter_condprintstats( ReporterDat
  * appropriate dispatch function
  */
 int reporter_print( ReporterData *stats, int type, int end ) {
+    DEBUGP("%s[%d]: reporter_print: type=%d\n", __FILE__, (int)__LINE__, type);
     switch ( type ) {
         case TRANSFER_REPORT:
+            DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
             statistics_reports[stats->mode]( &stats->info );
             if ( end != 0 && isPrintMSS( stats ) && !isUDP( stats ) ) {
                 PrintMSS( stats );
             }
             break;
         case SERVER_RELAY_REPORT:
+            DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
             serverstatistics_reports[stats->mode]( &stats->connection, &stats->info );
             break;
         case SETTINGS_REPORT:
+            DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
             settings_reports[stats->mode]( stats );
             break;
         case CONNECTION_REPORT:
+            DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
             stats->info.reserved_delay = connection_reports[stats->mode]( 
                                                &stats->connection,
                                                stats->info.transferID );
             break;
         case MULTIPLE_REPORT:
+            DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
             multiple_reports[stats->mode]( &stats->info );
             break;
         default:
diff -uprN iperf-2.0.9.orig/src/Reporter.c.~1~ iperf-2.0.9/src/Reporter.c.~1~
--- iperf-2.0.9.orig/src/Reporter.c.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Reporter.c.~1~	2017-02-11 02:06:37.194429113 +0900
@@ -0,0 +1,1223 @@
+/*---------------------------------------------------------------
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Reporter.c
+ * by Kevin Gibbs <kgibbs@nlanr.net>
+ *
+ * ________________________________________________________________ */
+
+#include <math.h>
+#include "headers.h"
+#include "Settings.hpp"
+#include "util.h"
+#include "Reporter.h"
+#include "Thread.h"
+#include "Locale.h"
+#include "PerfSocket.hpp"
+#include "SocketAddr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+/*
+  The following 4 functions are provided for Reporting
+  styles that do not have all the reporting formats. For
+  instance the provided CSV format does not have a settings
+  report so it uses settings_notimpl.
+  */
+void* connection_notimpl( Connection_Info * nused, int nuse ) { 
+    return NULL; 
+}
+void settings_notimpl( ReporterData * nused ) { }
+void statistics_notimpl( Transfer_Info * nused ) { }
+void serverstatistics_notimpl( Connection_Info *nused1, Transfer_Info *nused2 ) { }
+
+// To add a reporting style include its header here.
+#include "report_default.h"
+#include "report_CSV.h"
+
+// The following array of report structs contains the
+// pointers required for reporting in different reporting
+// styles. To add a reporting style add a report struct
+// below.
+report_connection connection_reports[kReport_MAXIMUM] = {
+    reporter_reportpeer,
+    CSV_peer
+};
+
+report_settings settings_reports[kReport_MAXIMUM] = {
+    reporter_reportsettings,
+    settings_notimpl
+};
+
+report_statistics statistics_reports[kReport_MAXIMUM] = {
+    reporter_printstats,
+    CSV_stats
+};
+
+report_serverstatistics serverstatistics_reports[kReport_MAXIMUM] = {
+    reporter_serverstats,
+    CSV_serverstats
+};
+
+report_statistics multiple_reports[kReport_MAXIMUM] = {
+    reporter_multistats,
+    CSV_stats
+};
+
+char buffer[64]; // Buffer for printing
+ReportHeader *ReportRoot = NULL;
+extern Condition ReportCond;
+extern Condition ReportDoneCond;
+int reporter_process_report ( ReportHeader *report );
+void process_report ( ReportHeader *report );
+int reporter_handle_packet( ReportHeader *report );
+int reporter_condprintstats( ReporterData *stats, MultiHeader *multireport, int force );
+int reporter_print( ReporterData *stats, int type, int end );
+void PrintMSS( ReporterData *stats );
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+static void gettcpistats(ReporterData *stats);
+#endif
+
+MultiHeader* InitMulti( thread_Settings *agent, int inID ) {
+    MultiHeader *multihdr = NULL;
+    if ( agent->mThreads > 1 || agent->mThreadMode == kMode_Server ) {
+        if ( isMultipleReport( agent ) ) {
+            multihdr = malloc(sizeof(MultiHeader) +  sizeof(ReporterData) +
+                              NUM_MULTI_SLOTS * sizeof(Transfer_Info));
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, multihdr);
+        } else {
+            multihdr = malloc(sizeof(MultiHeader));
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, multihdr);
+        }
+        if ( multihdr != NULL ) {
+            memset( multihdr, 0, sizeof(MultiHeader) );
+            Condition_Initialize( &multihdr->barrier );
+            multihdr->groupID = inID;
+            multihdr->threads = agent->mThreads;
+            if ( isMultipleReport( agent ) ) {
+                int i;
+                ReporterData *data = NULL;
+                multihdr->report = (ReporterData*)(multihdr + 1);
+                memset(multihdr->report, 0, sizeof(ReporterData));
+                multihdr->data = (Transfer_Info*)(multihdr->report + 1);
+                data = multihdr->report;
+                for ( i = 0; i < NUM_MULTI_SLOTS; i++ ) {
+                    multihdr->data[i].startTime = -1;
+                    multihdr->data[i].transferID = inID;
+                    multihdr->data[i].groupID = -2;
+                }
+                data->type = TRANSFER_REPORT;
+                if ( agent->mInterval != 0.0 ) {
+                    struct timeval *interval = &data->intervalTime;
+                    interval->tv_sec = (long) agent->mInterval;
+                    interval->tv_usec = (long) ((agent->mInterval - interval->tv_sec) 
+                                                * rMillion);
+                }
+                data->mHost = agent->mHost;
+                data->mLocalhost = agent->mLocalhost;
+                data->mBufLen = agent->mBufLen;
+                data->mMSS = agent->mMSS;
+                data->mTCPWin = agent->mTCPWin;
+                data->flags = agent->flags;
+                data->mThreadMode = agent->mThreadMode;
+                data->mode = agent->mReportMode;
+                data->info.mFormat = agent->mFormat;
+                data->info.mTTL = agent->mTTL;
+		if (data->mThreadMode == kMode_Server) 
+		    data->info.tcp.read.binsize = data->mBufLen / 8;
+                if ( isEnhanced( agent ) ) {
+		    data->info.mEnhanced = 1;
+		} else {
+		    data->info.mEnhanced = 0;
+		}
+                if ( isUDP( agent ) ) {
+                    multihdr->report->info.mUDP = (char)agent->mThreadMode;
+                    multihdr->report->info.mUDP = 0;
+                } else {
+                    multihdr->report->info.mTCP = (char)agent->mThreadMode;
+		}
+                if ( isConnectionReport( agent ) ) {
+                    data->type |= CONNECTION_REPORT;
+                    data->connection.peer = agent->peer;
+                    data->connection.size_peer = agent->size_peer;
+                    SockAddr_setPortAny( &data->connection.peer );
+                    data->connection.local = agent->local;
+                    data->connection.size_local = agent->size_local;
+                    SockAddr_setPortAny( &data->connection.local );
+                }
+            }
+        } else {
+            FAIL(1, "Out of Memory!!\n", agent);
+        }
+    }
+    return multihdr;
+}
+
+/*
+ * BarrierClient allows for multiple stream clients to be syncronized
+ */
+void BarrierClient( ReportHeader *agent ) {
+    Condition_Lock(agent->multireport->barrier);
+    agent->multireport->threads--;
+    if ( agent->multireport->threads == 0 ) {
+        // last one set time and wake up everyone
+        gettimeofday( &(agent->multireport->startTime), NULL );
+        Condition_Broadcast( &agent->multireport->barrier );
+    } else {
+        Condition_Wait( &agent->multireport->barrier );
+    }
+    agent->multireport->threads++;
+    Condition_Unlock( agent->multireport->barrier );
+    agent->report.startTime = agent->multireport->startTime;
+    agent->report.nextTime = agent->report.startTime;
+    TimeAdd( agent->report.nextTime, agent->report.intervalTime );
+}
+
+/*
+ * InitReport is called by a transfer agent (client or
+ * server) to setup the needed structures to communicate
+ * traffic.
+ */
+ReportHeader* InitReport( thread_Settings *agent ) {
+    ReportHeader *reporthdr = NULL;
+    ReporterData *data = NULL;
+    if ( isDataReport( agent ) ) {
+        /*
+         * Create in one big chunk
+         */
+        reporthdr = malloc( sizeof(ReportHeader) +
+                            NUM_REPORT_STRUCTS * sizeof(ReportStruct) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
+        if ( reporthdr != NULL ) {
+            // Only need to make sure the headers are clean
+            memset( reporthdr, 0, sizeof(ReportHeader));
+            reporthdr->data = (ReportStruct*)(reporthdr+1);
+            reporthdr->multireport = agent->multihdr;
+            data = &reporthdr->report;
+            reporthdr->reporterindex = NUM_REPORT_STRUCTS - 1;
+            data->info.transferID = agent->mSock;
+            data->info.groupID = (agent->multihdr != NULL ? agent->multihdr->groupID : -1);
+            data->type = TRANSFER_REPORT;
+            if ( agent->mInterval != 0.0 ) {
+                struct timeval *interval = &data->intervalTime;
+                interval->tv_sec = (long) agent->mInterval;
+                interval->tv_usec = (long) ((agent->mInterval - interval->tv_sec) * rMillion);
+            }
+            data->mHost = agent->mHost;
+            data->mLocalhost = agent->mLocalhost;
+            data->mBufLen = agent->mBufLen;
+            data->mMSS = agent->mMSS;
+            data->mTCPWin = agent->mTCPWin;
+            data->flags = agent->flags;
+            data->mThreadMode = agent->mThreadMode;
+            data->mode = agent->mReportMode;
+            data->info.mFormat = agent->mFormat;
+            data->info.mTTL = agent->mTTL;
+	    if (data->mThreadMode == kMode_Server) 
+		data->info.tcp.read.binsize = data->mBufLen / 8;
+            if ( isUDP( agent ) ) {
+		gettimeofday(&data->IPGstart, NULL);
+                reporthdr->report.info.mUDP = (char)agent->mThreadMode;
+            } else {
+                reporthdr->report.info.mTCP = (char)agent->mThreadMode;
+	    }
+	    if ( isEnhanced( agent ) ) {
+		data->info.mEnhanced = 1;
+	    } else {
+		data->info.mEnhanced = 0;
+	    }
+        } else {
+            FAIL(1, "Out of Memory!!\n", agent);
+        }
+    }
+    if ( isConnectionReport( agent ) ) {
+        if ( reporthdr == NULL ) {
+            /*
+             * Create in one big chunk
+             */
+            reporthdr = malloc( sizeof(ReportHeader) );
+            DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
+            if ( reporthdr != NULL ) {
+                // Only need to make sure the headers are clean
+                memset( reporthdr, 0, sizeof(ReportHeader));
+                data = &reporthdr->report;
+                data->info.transferID = agent->mSock;
+                data->info.groupID = -1;
+            } else {
+                FAIL(1, "Out of Memory!!\n", agent);
+            }
+        }
+        if ( reporthdr != NULL ) {
+            data->type |= CONNECTION_REPORT;
+            data->connection.peer = agent->peer;
+            data->connection.size_peer = agent->size_peer;
+            data->connection.local = agent->local;
+            data->connection.size_local = agent->size_local;
+        } else {
+            FAIL(1, "Out of Memory!!\n", agent);
+        }
+    }
+    if ( isConnectionReport( agent ) || isDataReport( agent ) ) {
+
+#ifdef HAVE_THREAD
+        /*
+         * Update the ReportRoot to include this report.
+         */
+        if ( reporthdr->report.mThreadMode == kMode_Client &&
+             reporthdr->multireport != NULL ) {
+            // syncronize watches on my mark......
+            BarrierClient( reporthdr );
+        } else {
+            if ( reporthdr->multireport != NULL && isMultipleReport( agent )) {
+                reporthdr->multireport->threads++;
+                if ( reporthdr->multireport->report->startTime.tv_sec == 0 ) {
+                    gettimeofday( &(reporthdr->multireport->report->startTime), NULL );
+                }
+                reporthdr->report.startTime = reporthdr->multireport->report->startTime;
+            } else {
+                // set start time
+                gettimeofday( &(reporthdr->report.startTime), NULL );
+            }
+            reporthdr->report.nextTime = reporthdr->report.startTime;
+            TimeAdd( reporthdr->report.nextTime, reporthdr->report.intervalTime );
+        }
+        Condition_Lock( ReportCond );
+        reporthdr->next = ReportRoot;
+        ReportRoot = reporthdr;
+        Condition_Signal( &ReportCond );
+        Condition_Unlock( ReportCond );
+#else
+        // set start time
+        gettimeofday( &(reporthdr->report.startTime), NULL );
+        // set next report time
+	reporthdr->report.nextTime = reporthdr->report.startTime;
+	TimeAdd( reporthdr->report.nextTime, reporthdr->report.intervalTime );
+        /*
+         * Process the report in this thread
+         */
+        reporthdr->next = NULL;
+        process_report ( reporthdr );
+#endif 
+    }
+    if ( !isDataReport( agent ) ) {
+        reporthdr = NULL;
+    }
+    return reporthdr;
+}
+
+/*
+ * ReportPacket is called by a transfer agent to record
+ * the arrival or departure of a "packet" (for TCP it 
+ * will actually represent many packets). This needs to
+ * be as simple and fast as possible as it gets called for
+ * every "packet".
+ */
+void ReportPacket( ReportHeader* agent, ReportStruct *packet ) {
+    if ( agent != NULL ) {
+        int index = agent->reporterindex;
+        /*
+         * First find the appropriate place to put the information
+         */
+        if ( agent->agentindex == NUM_REPORT_STRUCTS ) {
+            // Just need to make sure that reporter is not on the first
+            // item
+            while ( index == 0 ) {
+                Condition_Signal( &ReportCond );
+                Condition_Lock( ReportDoneCond );
+                Condition_Wait( &ReportDoneCond );
+                Condition_Unlock( ReportDoneCond );
+                index = agent->reporterindex;
+            }
+            agent->agentindex = 0;
+        }
+        // Need to make sure that reporter is not about to be "lapped"
+        while ( index - 1 == agent->agentindex ) {
+            Condition_Signal( &ReportCond );
+            Condition_Lock( ReportDoneCond );
+            Condition_Wait( &ReportDoneCond );
+            Condition_Unlock( ReportDoneCond );
+            index = agent->reporterindex;
+        }
+
+        // Put the information there
+        memcpy( agent->data + agent->agentindex, packet, sizeof(ReportStruct) );
+        
+        // Updating agentindex MUST be the last thing done
+        agent->agentindex++;
+#ifndef HAVE_THREAD
+        /*
+         * Process the report in this thread
+         */
+        process_report ( agent );
+#endif 
+    }
+}
+
+/*
+ * CloseReport is called by a transfer agent to finalize
+ * the report and signal transfer is over.
+ */
+void CloseReport( ReportHeader *agent, ReportStruct *packet ) {
+    int currpktid;
+    if ( agent != NULL) {
+
+        /*
+         * Using PacketID of -1 ends reporting
+         */
+	currpktid = packet->packetID;
+        packet->packetID = -1;
+        packet->packetLen = 0;
+        ReportPacket( agent, packet );
+        packet->packetID = currpktid;
+    }
+}
+
+/*
+ * EndReport signifies the agent no longer is interested
+ * in the report. Calls to GetReport will no longer be
+ * filled
+ */
+void EndReport( ReportHeader *agent ) {
+    if ( agent != NULL ) {
+        int index = agent->reporterindex;
+        while ( index != -1 ) {
+            thread_rest();
+            index = agent->reporterindex;
+        }
+        agent->agentindex = -1;
+#ifndef HAVE_THREAD
+        /*
+         * Process the report in this thread
+         */
+        process_report ( agent );
+#endif
+    }
+}
+
+/*
+ * GetReport is called by the agent after a CloseReport
+ * but before an EndReport to get the stats generated
+ * by the reporter thread.
+ */
+Transfer_Info *GetReport( ReportHeader *agent ) {
+    int index = agent->reporterindex;
+    while ( index != -1 ) {
+        thread_rest();
+        index = agent->reporterindex;
+    }
+    return &agent->report.info;
+}
+
+/*
+ * ReportSettings will generate a summary report for
+ * settings being used with Listeners or Clients
+ */
+void ReportSettings( thread_Settings *agent ) {
+    if ( isSettingsReport( agent ) ) {
+        /*
+         * Create in one big chunk
+         */
+        ReportHeader *reporthdr = malloc( sizeof(ReportHeader) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
+    
+        if ( reporthdr != NULL ) {
+            ReporterData *data = &reporthdr->report;
+            data->info.transferID = agent->mSock;
+            data->info.groupID = -1;
+            reporthdr->agentindex = -1;
+            reporthdr->reporterindex = -1;
+        
+            data->mHost = agent->mHost;
+            data->mLocalhost = agent->mLocalhost;
+            data->mode = agent->mReportMode;
+            data->type = SETTINGS_REPORT;
+            data->mBufLen = agent->mBufLen;
+            data->mMSS = agent->mMSS;
+            data->mTCPWin = agent->mTCPWin;
+            data->flags = agent->flags;
+            data->mThreadMode = agent->mThreadMode;
+            data->mPort = agent->mPort;
+            data->info.mFormat = agent->mFormat;
+            data->info.mTTL = agent->mTTL;
+            data->connection.peer = agent->peer;
+            data->connection.size_peer = agent->size_peer;
+            data->connection.local = agent->local;
+            data->connection.size_local = agent->size_local;
+            data->mUDPRate = agent->mUDPRate;
+            data->mUDPRateUnits = agent->mUDPRateUnits;
+    #ifdef HAVE_THREAD
+            /*
+             * Update the ReportRoot to include this report.
+             */
+            Condition_Lock( ReportCond );
+            reporthdr->next = ReportRoot;
+            ReportRoot = reporthdr;
+            Condition_Signal( &ReportCond );
+            Condition_Unlock( ReportCond );
+    #else
+            /*
+             * Process the report in this thread
+             */
+            reporthdr->next = NULL;
+            process_report ( reporthdr );
+    #endif 
+        } else {
+            FAIL(1, "Out of Memory!!\n", agent);
+        }
+    }
+}
+
+/*
+ * ReportServerUDP will generate a report of the UDP
+ * statistics as reported by the server on the client
+ * side.
+ */
+void ReportServerUDP( thread_Settings *agent, server_hdr *server ) {
+    if ( (ntohl(server->flags) & HEADER_VERSION1) != 0 &&
+         isServerReport( agent ) ) {
+        /*
+         * Create in one big chunk
+         */
+        ReportHeader *reporthdr = malloc( sizeof(ReportHeader) );
+        DEBUGP("%s[%d]: malloc: %p\n", __FILE__, (int)__LINE__, reporthdr);
+        Transfer_Info *stats = &reporthdr->report.info;
+
+        if ( reporthdr != NULL ) {
+            stats->transferID = agent->mSock;
+            stats->groupID = (agent->multihdr != NULL ? agent->multihdr->groupID 
+                                                      : -1);
+            reporthdr->agentindex = -1;
+            reporthdr->reporterindex = -1;
+
+            reporthdr->report.type = SERVER_RELAY_REPORT;
+            reporthdr->report.mode = agent->mReportMode;
+            stats->mFormat = agent->mFormat;
+            stats->jitter = ntohl( server->jitter1 );
+            stats->jitter += ntohl( server->jitter2 ) / (double)rMillion;
+            stats->TotalLen = (((max_size_t) ntohl( server->total_len1 )) << 32) +
+                                  ntohl( server->total_len2 ); 
+            stats->startTime = 0;
+            stats->endTime = ntohl( server->stop_sec );
+            stats->endTime += ntohl( server->stop_usec ) / (double)rMillion;
+            stats->cntError = ntohl( server->error_cnt );
+            stats->cntOutofOrder = ntohl( server->outorder_cnt );
+            stats->cntDatagrams = ntohl( server->datagrams );
+            stats->transit.minTransit = ntohl( server->minTransit1 );
+            stats->transit.minTransit += ntohl( server->minTransit2 ) / (double)rMillion;
+            stats->transit.maxTransit = ntohl( server->maxTransit1 );
+            stats->transit.maxTransit += ntohl( server->maxTransit2 ) / (double)rMillion;
+            stats->transit.sumTransit = ntohl( server->sumTransit1 );
+            stats->transit.sumTransit += ntohl( server->sumTransit2 ) / (double)rMillion;
+            stats->transit.meanTransit = ntohl( server->meanTransit1 );
+            stats->transit.meanTransit += ntohl( server->meanTransit2 ) / (double)rMillion;
+            stats->transit.m2Transit = ntohl( server->m2Transit1 );
+            stats->transit.m2Transit += ntohl( server->m2Transit2 ) / (double)rMillion;
+            stats->transit.vdTransit = ntohl( server->vdTransit1 );
+            stats->transit.vdTransit += ntohl( server->vdTransit2 ) / (double)rMillion;
+            stats->transit.cntTransit = ntohl( server->cntTransit );
+            stats->IPGcnt = ntohl( server->IPGcnt );
+            stats->IPGsum = ntohl( server->IPGsum );
+
+            stats->mUDP = (char)kMode_Server;
+
+            stats->pcpu[0] = (double)ntohl(server->pcpu[0]);
+            stats->pcpu[1] = (double)ntohl(server->pcpu[1]);
+            stats->pcpu[2] = (double)ntohl(server->pcpu[2]);
+            stats->pcpu[3] = (double)ntohl(server->pcpu[3]);
+            DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+            DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n",
+                   stats->pcpu[0] , stats->pcpu[1] , stats->pcpu[2], stats->pcpu[3]);
+
+            reporthdr->report.connection.peer = agent->local;
+            reporthdr->report.connection.size_peer = agent->size_local;
+            reporthdr->report.connection.local = agent->peer;
+            reporthdr->report.connection.size_local = agent->size_peer;
+            
+#ifdef HAVE_THREAD
+            /*
+             * Update the ReportRoot to include this report.
+             */
+            Condition_Lock( ReportCond );
+            reporthdr->next = ReportRoot;
+            ReportRoot = reporthdr;
+            Condition_Signal( &ReportCond );
+            Condition_Unlock( ReportCond );
+#else
+            /*
+             * Process the report in this thread
+             */
+            reporthdr->next = NULL;
+            process_report ( reporthdr );
+#endif 
+        } else {
+            FAIL(1, "Out of Memory!!\n", agent);
+        }
+    }
+}
+
+/*
+ * This function is called only when the reporter thread
+ * This function is the loop that the reporter thread processes
+ */
+void reporter_spawn( thread_Settings *thread ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    do {
+        // This section allows for safe exiting with Ctrl-C
+        Condition_Lock ( ReportCond );
+        if ( ReportRoot == NULL ) {
+            // Allow main thread to exit if Ctrl-C is received
+            thread_setignore();
+            Condition_Wait ( &ReportCond );
+            // Stop main thread from exiting until done with all reports
+            thread_unsetignore();
+        }
+        Condition_Unlock ( ReportCond );
+
+again:
+        if ( ReportRoot != NULL ) {
+            ReportHeader *temp = ReportRoot;
+            //Condition_Unlock ( ReportCond );
+            if ( reporter_process_report ( temp ) ) {
+                // This section allows for more reports to be added while
+                // the reporter is processing reports without needing to
+                // stop the reporter or immediately notify it
+                Condition_Lock ( ReportCond );
+                if ( temp == ReportRoot ) {
+                    // no new reports
+                    ReportRoot = temp->next;
+                } else {
+                    // new reports added
+                    ReportHeader *itr = ReportRoot;
+                    while ( itr->next != temp ) {
+                        itr = itr->next;
+                    }
+                    itr->next = temp->next;
+                }
+                // finished with report so free it
+                free( temp );
+                DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, temp);
+                Condition_Unlock ( ReportCond );
+                Condition_Signal( &ReportDoneCond );
+                if (ReportRoot)
+                    goto again;
+            }
+            Condition_Signal( &ReportDoneCond );
+	    /* 
+	     * Suspend the reporter thread for 10 milliseconds
+	     *
+	     * This allows the thread to receive client or server threads'
+	     * packet events in "aggregates."  This can reduce context 
+	     * switching allowing for better CPU utilization, 
+	     * which is very noticble on CPU constrained systems.
+	     * 
+	     * If the realtime flag is set, then don't invoke the 
+	     * suspend.  This should give better reporter timing on 
+	     * higher end systems, where a busy-loop thread can be 
+	     * scheduled without impacting other threads.
+	     *
+	     * Note that if the reporter thread is signficantly slower 
+	     * than the Client or Server (traffic) threads this suspend 
+	     * will still be called even though the traffic threads can be 
+	     * blocked on the shared memory being full.  Probably should 
+	     * detect those and avoid the suspend under such conditions.  
+	     * It's not a big deal though because the traffic threads under  
+	     * normal conditions are much slower than the reporter thread.
+	     * The exception is when there are things like sustained 
+	     * write errors. Hence, such an optimization is deferred 
+	     * for a later date.
+	     *
+	     * Also note, a possible better implementation is for the 
+	     * reporter thread to block on a traffic thread's signal
+	     * instead of a 10 ms suspend.  That implementation 
+	     * would have to be profiled against this one to make sure
+	     * it indeed gave better performance.  Again, deferred.
+	     *
+	     * Final note, usleep() is being deprecated for nanosleep(), 
+	     * so use nanosleep if available
+	     */
+	    if ( !isRealtime( thread ) ) {
+#ifdef HAVE_NANOSLEEP 
+		{
+		    struct timespec requested;
+		    requested.tv_sec  = 0;
+		    requested.tv_nsec = 10000000L;
+		    nanosleep(&requested, NULL);
+		}
+#else 
+		usleep(10000);
+#endif
+	    }
+        }
+    } while ( 1 );
+}
+
+/*
+ * Used for single threaded reporting
+ */
+void process_report ( ReportHeader *report ) {
+    if ( report != NULL ) {
+        if ( reporter_process_report( report ) ) {
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, report);
+            free( report );
+            report = NULL;
+        }
+    }
+}
+
+/*
+ * Process reports starting with "reporthdr"
+ */
+int reporter_process_report ( ReportHeader *reporthdr ) {
+    //DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    int need_free = 0;
+
+    // Recursively process reports
+    if ( reporthdr->next != NULL ) {
+        if ( reporter_process_report( reporthdr->next ) ) {
+            // If we are done with this report then free it
+            ReportHeader *temp = reporthdr->next;
+            reporthdr->next = reporthdr->next->next;
+            DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, temp);
+            free( temp );
+            temp = NULL;
+        }
+    }
+
+    if ( (reporthdr->report.type & SETTINGS_REPORT) != 0 ) {
+        reporthdr->report.type &= ~SETTINGS_REPORT;
+        return reporter_print( &reporthdr->report, SETTINGS_REPORT, 1 );
+    } else if ( (reporthdr->report.type & CONNECTION_REPORT) != 0 ) {
+        reporthdr->report.type &= ~CONNECTION_REPORT;
+        reporter_print( &reporthdr->report, CONNECTION_REPORT,
+                               (reporthdr->report.type == 0 ? 1 : 0) );
+        if ( reporthdr->multireport != NULL && isMultipleReport( (&reporthdr->report) )) {
+            if ( (reporthdr->multireport->report->type & CONNECTION_REPORT) != 0 ) {
+                reporthdr->multireport->report->type &= ~CONNECTION_REPORT;
+                reporter_print( reporthdr->multireport->report, CONNECTION_REPORT,
+                                (reporthdr->report.type == 0 ? 1 : 0) );
+            }
+        }
+    } else if ( (reporthdr->report.type & SERVER_RELAY_REPORT) != 0 ) {
+        reporthdr->report.type &= ~SERVER_RELAY_REPORT;
+        return reporter_print( &reporthdr->report, SERVER_RELAY_REPORT, 1 );
+    }
+    if ( (reporthdr->report.type & TRANSFER_REPORT) != 0 ) {
+        // If there are more packets to process then handle them
+        if ( reporthdr->reporterindex >= 0 ) {
+            // Need to make sure we do not pass the "agent"
+            while ( reporthdr->reporterindex != reporthdr->agentindex - 1 ) {
+                if ( reporthdr->reporterindex == NUM_REPORT_STRUCTS - 1 ) {
+                    if ( reporthdr->agentindex == 0 ) {
+                        break;
+                    } else {
+                        reporthdr->reporterindex = 0;
+                    }
+                } else {
+                    reporthdr->reporterindex++;
+                }
+                if ( reporter_handle_packet( reporthdr ) ) {
+                    // No more packets to process
+                    reporthdr->reporterindex = -1;
+                    break;
+                }
+            }
+        }
+        // If the agent is done with the report then free it
+        if ( reporthdr->agentindex == -1 ) {
+            need_free = 1;
+        }
+    }
+    return need_free;
+}
+
+/*
+ * Updates connection stats
+ */
+int reporter_handle_packet( ReportHeader *reporthdr ) {
+    //DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    ReportStruct *packet = &reporthdr->data[reporthdr->reporterindex];
+    ReporterData *data = &reporthdr->report;
+    Transfer_Info *stats = &reporthdr->report.info;
+    int finished = 0;
+    double usec_transit;
+
+    data->packetTime = packet->packetTime;
+    stats->socket = packet->socket;
+    if ( packet->packetID < 0 ) {
+        finished = 1;
+        if ( reporthdr->report.mThreadMode != kMode_Client ) {
+            data->TotalLen += packet->packetLen;
+        }
+    } else {
+	if (!packet->emptyreport) {
+	    // update fields common to TCP and UDP, client and server
+	    data->TotalLen += packet->packetLen;
+	    // update fields common to UDP client and server
+            if ( isUDP( data ) ) {
+		data->cntDatagrams++;
+		stats->IPGsum += TimeDifference(data->packetTime, data->IPGstart );
+		stats->IPGcnt++;
+		data->IPGstart = data->packetTime;
+		// Finally, update UDP server fields
+		if (stats->mUDP == kMode_Server) {
+		    //subsequent packets
+		    double transit;
+		    double deltaTransit;            
+		    transit = TimeDifference( packet->packetTime, packet->sentTime );
+		    // packet loss occured if the datagram numbers aren't sequential 
+		    if ( packet->packetID != data->PacketID + 1 ) {
+			if (packet->packetID < data->PacketID + 1 ) {
+			    data->cntOutofOrder++;
+			} else {
+			    data->cntError += packet->packetID - data->PacketID - 1;
+			}
+		    }
+		    // never decrease datagramID (e.g. if we get an out-of-order packet)
+		    if ( packet->packetID > data->PacketID ) {
+			data->PacketID = packet->packetID;
+		    }
+		    if (stats->transit.totcntTransit == 0) {
+			// Very first packet
+			stats->transit.minTransit = transit;
+			stats->transit.maxTransit = transit;
+			stats->transit.sumTransit = transit;
+			stats->transit.cntTransit = 1;
+			stats->transit.totminTransit = transit;
+			stats->transit.totmaxTransit = transit;
+			stats->transit.totsumTransit = transit;
+			stats->transit.totcntTransit = 1;
+			// For variance, working units is microseconds
+			usec_transit = transit * 1e6;
+			stats->transit.vdTransit = usec_transit;
+			stats->transit.meanTransit = usec_transit;
+			stats->transit.m2Transit = usec_transit * usec_transit;
+			stats->transit.totvdTransit = usec_transit;
+			stats->transit.totmeanTransit = usec_transit;
+			stats->transit.totm2Transit = usec_transit * usec_transit;
+		    } else {
+			// from RFC 1889, Real Time Protocol (RTP) 
+			// J = J + ( | D(i-1,i) | - J ) / 
+			// Compute jitter
+			deltaTransit = transit - stats->transit.lastTransit;
+			if ( deltaTransit < 0.0 ) {
+			    deltaTransit = -deltaTransit;
+			}
+			stats->jitter += (deltaTransit - stats->jitter) / (16.0);
+			// Compute end/end delay stats
+			stats->transit.sumTransit += transit;
+			stats->transit.cntTransit++;
+			stats->transit.totsumTransit += transit;
+			stats->transit.totcntTransit++;
+			// mean min max tests
+			if (transit < stats->transit.minTransit) {
+			    stats->transit.minTransit=transit;
+			}
+			if (transit < stats->transit.totminTransit) {
+			    stats->transit.totminTransit=transit;
+			}
+			if (transit > stats->transit.maxTransit) {
+			    stats->transit.maxTransit=transit;
+			}
+			if (transit > stats->transit.totmaxTransit) {
+			    stats->transit.totmaxTransit=transit;
+			}
+			// For variance, working units is microseconds
+			// variance interval
+			usec_transit = transit * 1e6;
+			stats->transit.vdTransit = usec_transit - stats->transit.meanTransit;
+			stats->transit.meanTransit = stats->transit.meanTransit + (stats->transit.vdTransit / stats->transit.cntTransit);
+			stats->transit.m2Transit = stats->transit.m2Transit + (stats->transit.vdTransit * (usec_transit - stats->transit.meanTransit));
+			// variance total
+			stats->transit.totvdTransit = usec_transit - stats->transit.totmeanTransit;
+			stats->transit.totmeanTransit = stats->transit.totmeanTransit + (stats->transit.totvdTransit / stats->transit.totcntTransit);
+			stats->transit.totm2Transit = stats->transit.totm2Transit + (stats->transit.totvdTransit * (usec_transit - stats->transit.totmeanTransit));
+		    }
+		    stats->transit.lastTransit = transit;
+		}
+	    } else if (reporthdr->report.mThreadMode == kMode_Server && (packet->packetLen > 0)) {
+		int bin;
+		// mean min max tests
+		stats->tcp.read.cntRead++;
+		stats->tcp.read.totcntRead++;
+		bin = (int)floor((packet->packetLen -1)/stats->tcp.read.binsize);
+		stats->tcp.read.bins[bin]++;
+		stats->tcp.read.totbins[bin]++;
+	    } else if (reporthdr->report.mThreadMode == kMode_Client) {
+		if (packet->errwrite) { 
+		    stats->tcp.write.WriteErr++;
+		    stats->tcp.write.totWriteErr++;
+		}
+		else { 
+		    stats->tcp.write.WriteCnt++;
+		    stats->tcp.write.totWriteCnt++;
+		}
+	    }
+	} else if ((stats->mUDP == kMode_Server) &&	\
+		   (stats->transit.cntTransit == 0)) {
+	    // This is the case when empty reports
+	    // cross the report interval boundary
+	    // Hence, set the per interval min to infinity
+	    // and the per interval max and sum to zero
+	    stats->transit.minTransit = FLT_MAX;
+	    stats->transit.maxTransit = FLT_MIN;
+	    stats->transit.sumTransit = 0;
+	    stats->transit.vdTransit = 0;
+	    stats->transit.meanTransit = 0;
+	    stats->transit.m2Transit = 0;
+	}
+    }
+    // Print a report if appropriate
+    return reporter_condprintstats( &reporthdr->report, reporthdr->multireport, finished );
+}
+
+/*
+ * Handles summing of threads
+ */
+void reporter_handle_multiple_reports( MultiHeader *reporthdr, Transfer_Info *stats, int force ) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    if ( reporthdr != NULL ) {
+        if ( reporthdr->threads > 1 ) {
+            int i;
+            Transfer_Info *current = NULL;
+            // Search for start Time
+            for ( i = 0; i < NUM_MULTI_SLOTS; i++ ) {
+                current = &reporthdr->data[i];
+                if ( current->startTime == stats->startTime ) {
+                    break;
+                }
+            }
+            if ( current->startTime != stats->startTime ) {
+                // Find first available
+                for ( i = 0; i < NUM_MULTI_SLOTS; i++ ) {
+                    current = &reporthdr->data[i];
+                    if ( current->startTime < 0 ) {
+                        break;
+                    }
+                }
+                current->cntDatagrams = stats->cntDatagrams;
+                current->cntError = stats->cntError;
+                current->cntOutofOrder = stats->cntOutofOrder;
+                current->TotalLen = stats->TotalLen;
+                current->mFormat = stats->mFormat;
+                current->mEnhanced = stats->mEnhanced;
+                current->endTime = stats->endTime;
+                current->jitter = stats->jitter;
+                current->startTime = stats->startTime;
+		current->IPGcnt = stats->IPGcnt;
+                current->startTime = stats->startTime;
+		current->IPGsum = stats->IPGsum;
+		current->mUDP = stats->mUDP;
+		current->mTCP = stats->mTCP;
+		if (stats->mTCP == kMode_Server) {
+		    int ix;
+		    current->tcp.read.cntRead = stats->tcp.read.cntRead;
+		    for (ix = 0; ix < 8; ix++) {
+			current->tcp.read.bins[ix] = stats->tcp.read.bins[ix];
+		    }
+		} else if (stats->mTCP == kMode_Client) {
+		    current->tcp.write.WriteErr = stats->tcp.write.WriteErr;
+		    current->tcp.write.WriteCnt = stats->tcp.write.WriteCnt;
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+		    current->tcp.write.TCPretry = stats->tcp.write.TCPretry;
+#endif
+		}
+                current->free = 1;
+            } else {
+                current->cntDatagrams += stats->cntDatagrams;
+                current->cntError += stats->cntError;
+                current->cntOutofOrder += stats->cntOutofOrder;
+                current->TotalLen += stats->TotalLen;
+		current->IPGcnt += stats->IPGcnt;
+		if (stats->mTCP == kMode_Server) {
+		    int ix;
+		    current->tcp.read.cntRead += stats->tcp.read.cntRead;
+		    for (ix = 0; ix < 8; ix++) {
+			current->tcp.read.bins[ix] += stats->tcp.read.bins[ix];
+		    }
+		} else if (stats->mTCP == kMode_Client) {
+		    current->tcp.write.WriteErr += stats->tcp.write.WriteErr;
+		    current->tcp.write.WriteCnt += stats->tcp.write.WriteCnt;
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+		    current->tcp.write.TCPretry += stats->tcp.write.TCPretry;
+#endif
+		}
+                if ( current->endTime < stats->endTime ) {
+                    current->endTime = stats->endTime;
+                }
+                if ( current->jitter < stats->jitter ) {
+                    current->jitter = stats->jitter;
+                }
+                current->free++;
+                if ( current->free == reporthdr->threads ) {
+                    void *reserved = reporthdr->report->info.reserved_delay;
+                    current->free = force;
+                    memcpy( &reporthdr->report->info, current, sizeof(Transfer_Info) );
+                    current->startTime = -1;
+                    reporthdr->report->info.reserved_delay = reserved;
+                    reporter_print( reporthdr->report, MULTIPLE_REPORT, force );
+                }
+            }
+        }
+    }
+}
+
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+static void gettcpistats (ReporterData *stats) {
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    struct tcp_info tcp_internal;
+    socklen_t tcp_info_length = sizeof(struct tcp_info);
+    int retry;
+    if (stats->info.mEnhanced && stats->info.mTCP == kMode_Client) {
+	// Read the TCP retry stats for a client.  Do this
+	// on  a report interval period.
+	if (getsockopt(stats->info.socket, IPPROTO_TCP, TCP_INFO, &tcp_internal, &tcp_info_length) < 0) {
+	    WARN_errno( 1 , "getsockopt");
+	    retry = 0;
+	} else {
+	    retry = tcp_internal.tcpi_total_retrans - stats->info.tcp.write.lastTCPretry;
+	}
+	stats->info.tcp.write.TCPretry = retry;
+	stats->info.tcp.write.totTCPretry += retry;
+	stats->info.tcp.write.lastTCPretry = tcp_internal.tcpi_total_retrans;
+	stats->info.tcp.write.cwnd = tcp_internal.tcpi_snd_cwnd * tcp_internal.tcpi_snd_mss / 1024;
+	stats->info.tcp.write.rtt = tcp_internal.tcpi_rtt;
+    } 
+}
+#endif
+/*
+ * Prints reports conditionally
+ */
+int reporter_condprintstats( ReporterData *stats, MultiHeader *multireport, int force ) {
+
+    if ( force ) {
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+	gettcpistats(stats);
+#endif
+        stats->info.cntOutofOrder = stats->cntOutofOrder;
+        // assume most of the time out-of-order packets are not
+        // duplicate packets, so conditionally subtract them from the lost packets.
+        stats->info.cntError = stats->cntError;
+        if ( stats->info.cntError > stats->info.cntOutofOrder ) {
+            stats->info.cntError -= stats->info.cntOutofOrder;
+        }
+        stats->info.cntDatagrams = ((stats->info.mUDP == kMode_Server) ? stats->PacketID : stats->cntDatagrams);
+        stats->info.TotalLen = stats->TotalLen;
+        stats->info.startTime = 0;
+        stats->info.endTime = TimeDifference( stats->packetTime, stats->startTime );
+	stats->info.transit.minTransit = stats->info.transit.totminTransit;
+	stats->info.transit.maxTransit = stats->info.transit.totmaxTransit;
+	stats->info.transit.cntTransit = stats->info.transit.totcntTransit;
+	stats->info.transit.sumTransit = stats->info.transit.totsumTransit;
+	stats->info.transit.meanTransit = stats->info.transit.totmeanTransit;
+	stats->info.transit.m2Transit = stats->info.transit.totm2Transit;
+	stats->info.transit.vdTransit = stats->info.transit.totvdTransit;
+	if (stats->info.mTCP == kMode_Client) {
+	    stats->info.tcp.write.WriteErr = stats->info.tcp.write.totWriteErr;
+	    stats->info.tcp.write.WriteCnt = stats->info.tcp.write.totWriteCnt;
+	    stats->info.tcp.write.TCPretry = stats->info.tcp.write.totTCPretry;
+	}
+	if (stats->info.mTCP == kMode_Server) {
+	    int ix;
+	    stats->info.tcp.read.cntRead = stats->info.tcp.read.totcntRead;
+	    for (ix = 0; ix < 8; ix++) {
+		stats->info.tcp.read.bins[ix] = stats->info.tcp.read.totbins[ix];
+	    }
+	}
+	if (stats->info.endTime > 0) {
+	    stats->info.IPGcnt = (int) (stats->cntDatagrams / stats->info.endTime);
+	} else {
+	    stats->info.IPGcnt = 0;
+	}
+	stats->info.IPGsum = 1;
+        stats->info.free = 1;
+
+        reporter_print( stats, TRANSFER_REPORT, force );
+        if ( isMultipleReport(stats) ) {
+            reporter_handle_multiple_reports( multireport, &stats->info, force );
+        }
+    } else while ((stats->intervalTime.tv_sec != 0 || 
+                   stats->intervalTime.tv_usec != 0) && 
+                  TimeDifference( stats->nextTime, 
+                                  stats->packetTime ) < 0 ) {
+#ifdef HAVE_STRUCT_TCP_INFO_TCPI_TOTAL_RETRANS
+	    gettcpistats(stats);
+#endif
+	    stats->info.cntOutofOrder = stats->cntOutofOrder - stats->lastOutofOrder;
+	    stats->lastOutofOrder = stats->cntOutofOrder;
+	    // assume most of the  time out-of-order packets are not
+	    // duplicate packets, so conditionally subtract them from the lost packets.
+	    stats->info.cntError = stats->cntError - stats->lastError;
+	    if ( stats->info.cntError > stats->info.cntOutofOrder ) {
+		stats->info.cntError -= stats->info.cntOutofOrder;
+	    }
+	    stats->lastError = stats->cntError;
+	    stats->info.cntDatagrams = ((stats->info.mUDP == kMode_Server) ? stats->PacketID - stats->lastDatagrams :
+					stats->cntDatagrams - stats->lastDatagrams);
+	    stats->lastDatagrams = ((stats->info.mUDP == kMode_Server) ? stats->PacketID : stats->cntDatagrams);
+	    stats->info.TotalLen = stats->TotalLen - stats->lastTotal;
+	    stats->lastTotal = stats->TotalLen;
+	    stats->info.startTime = stats->info.endTime;
+	    stats->info.endTime = TimeDifference( stats->nextTime, stats->startTime );
+	    TimeAdd( stats->nextTime, stats->intervalTime );
+	    stats->info.free = 0;
+	    reporter_print( stats, TRANSFER_REPORT, force );
+	    if ( isMultipleReport(stats) ) {
+		reporter_handle_multiple_reports( multireport, &stats->info, force );
+	    }
+	    /*
+	     * Reset transfer stats now that both the individual and SUM reports
+	     * have completed
+	     */
+	    if (stats->info.mUDP) {
+		stats->info.IPGcnt = 0;
+		stats->info.IPGsum = 0;
+	    }
+	    if (stats->info.mEnhanced) {
+		if (stats->info.mTCP == (char)kMode_Client) {
+		    stats->info.tcp.write.WriteCnt = 0;
+		    stats->info.tcp.write.WriteErr = 0;
+		} else if (stats->info.mTCP == (char)kMode_Server) {
+		    int ix;
+		    stats->info.tcp.read.cntRead = 0;
+		    for (ix = 0; ix < 8; ix++) { 
+			stats->info.tcp.read.bins[ix] = 0;
+		    }
+		}
+	    }
+	}
+    return force;
+}
+
+/*
+ * This function handles multiple format printing by sending to the
+ * appropriate dispatch function
+ */
+int reporter_print( ReporterData *stats, int type, int end ) {
+    DEBUGP("%s[%d]: reporter_print: type=%d\n", __FILE__, (int)__LINE__, type);
+    switch ( type ) {
+        case TRANSFER_REPORT:
+            statistics_reports[stats->mode]( &stats->info );
+            if ( end != 0 && isPrintMSS( stats ) && !isUDP( stats ) ) {
+                PrintMSS( stats );
+            }
+            break;
+        case SERVER_RELAY_REPORT:
+            serverstatistics_reports[stats->mode]( &stats->connection, &stats->info );
+            break;
+        case SETTINGS_REPORT:
+            settings_reports[stats->mode]( stats );
+            break;
+        case CONNECTION_REPORT:
+            stats->info.reserved_delay = connection_reports[stats->mode]( 
+                                               &stats->connection,
+                                               stats->info.transferID );
+            break;
+        case MULTIPLE_REPORT:
+            multiple_reports[stats->mode]( &stats->info );
+            break;
+        default:
+            fprintf( stderr, "Printing type not implemented! No Output\n" );
+    }
+    fflush( stdout );
+    return end;
+}
+
+/* -------------------------------------------------------------------
+ * Report the MSS and MTU, given the MSS (or a guess thereof)
+ * ------------------------------------------------------------------- */
+
+// compare the MSS against the (MTU - 40) to (MTU - 80) bytes.
+// 40 byte IP header and somewhat arbitrarily, 40 more bytes of IP options.
+
+#define checkMSS_MTU( inMSS, inMTU ) (inMTU-40) >= inMSS  &&  inMSS >= (inMTU-80)
+
+void PrintMSS( ReporterData *stats ) {
+    int inMSS = getsock_tcp_mss( stats->info.transferID );
+
+    if ( inMSS <= 0 ) {
+        printf( report_mss_unsupported, stats->info.transferID );
+    } else {
+        char* net;
+        int mtu = 0;
+
+        if ( checkMSS_MTU( inMSS, 1500 ) ) {
+            net = "ethernet";
+            mtu = 1500;
+        } else if ( checkMSS_MTU( inMSS, 4352 ) ) {
+            net = "FDDI";
+            mtu = 4352;
+        } else if ( checkMSS_MTU( inMSS, 9180 ) ) {
+            net = "ATM";
+            mtu = 9180;
+        } else if ( checkMSS_MTU( inMSS, 65280 ) ) {
+            net = "HIPPI";
+            mtu = 65280;
+        } else if ( checkMSS_MTU( inMSS, 576 ) ) {
+            net = "minimum";
+            mtu = 576;
+            printf( "%s", warn_no_pathmtu );
+        } else {
+            mtu = inMSS + 40;
+            net = "unknown interface";
+        }
+
+        printf( report_mss,
+                stats->info.transferID, inMSS, mtu, net );
+    }
+}
+// end ReportMSS
+
+#ifdef __cplusplus
+} /* end extern "C" */
+#endif
diff -uprN iperf-2.0.9.orig/src/Server.cpp iperf-2.0.9/src/Server.cpp
--- iperf-2.0.9.orig/src/Server.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Server.cpp	2017-02-13 07:44:40.293875311 +0900
@@ -68,6 +68,18 @@
 #include <sys/mman.h>
 #endif
 
+#include <sys/time.h>
+#include <sys/resource.h>
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+static void cpu_util(uint32_t pcpu[3]);
+uint32_t g_pcpu[4] = {0};
+
 /* -------------------------------------------------------------------
  * Stores connected socket and socket info.
  * ------------------------------------------------------------------- */
@@ -78,6 +90,8 @@ Server::Server( thread_Settings *inSetti
 
     // initialize buffer
     mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
+
     FAIL_errno( mBuf == NULL, "No memory for buffer\n", mSettings );
 }
 
@@ -87,11 +101,16 @@ Server::Server( thread_Settings *inSetti
 
 Server::~Server() {
     if ( mSettings->mSock != INVALID_SOCKET ) {
+        DEBUGP("%s[%d]: close\n", __FILE__, (int)__LINE__);
         int rc = close( mSettings->mSock );
         WARN_errno( rc == SOCKET_ERROR, "close" );
         mSettings->mSock = INVALID_SOCKET;
     }
-    DELETE_ARRAY( mBuf );
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+    }
 }
 
 void Server::Sig_Int( int inSigno ) {
@@ -128,7 +147,32 @@ void Server::Run( void ) {
     message.msg_controllen = sizeof(ctrl);
 #endif
 
+#ifdef HAVE_SCHED_SETSCHEDULER
+    if (0 <= mSettings->mAffinity) {
+        cpu_set_t cpu_set;
+        CPU_ZERO(&cpu_set);
+        if ( mSettings->mAffinityEnd < 0) {
+            CPU_SET(mSettings->mAffinity, &cpu_set);
+        } else {
+            if (mSettings->mAffinityComma) {
+                CPU_SET(mSettings->mAffinity, &cpu_set);
+                CPU_SET(mSettings->mAffinityEnd, &cpu_set);
+            } else {
+                int i;
+                for (i = mSettings->mAffinity; i < mSettings->mAffinityEnd; ++i) {
+                    CPU_SET(i, &cpu_set);
+                }
+            }
+        }
+        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {
+            printf("sched_setaffinity error!!\n");
+            exit(-1);
+        }
+    }
+#endif
+
     reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
     if ( reportstruct != NULL ) {
         reportstruct->packetID = 0;
         mSettings->reporthdr = InitReport( mSettings );
@@ -184,6 +228,9 @@ void Server::Run( void ) {
 	    mEndTime.setnow();
 	    mEndTime.add( mSettings->mAmount / 100.0 );
 	}
+
+    cpu_util(NULL);
+
         do {
 	    reportstruct->emptyreport=0;
 #if HAVE_DECL_SO_TIMESTAMP
@@ -272,6 +319,12 @@ void Server::Run( void ) {
             }
         } while (running); 
                 
+
+        cpu_util(mSettings->pcpu);
+        DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+        DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n",
+               mSettings->pcpu[0] , mSettings->pcpu[1] , mSettings->pcpu[2], mSettings->pcpu[3]);
+
         // stop timing 
         gettimeofday( &(reportstruct->packetTime), NULL );
         
@@ -288,16 +341,42 @@ void Server::Run( void ) {
             // send back an acknowledgement of the terminating datagram 
             write_UDP_AckFIN( ); 
         }
+        //write_UDP_AckFIN( );
     } else {
         FAIL(1, "Out of memory! Closing server thread\n", mSettings);
     }
 
     Mutex_Lock( &clients_mutex );     
-    Iperf_delete( &(mSettings->peer), &clients ); 
+    if (clients != NULL) {
+        DEBUGP("%s[%d]: Iperf_delete: %p\n", __FILE__, (int)__LINE__, clients);
+        //Iperf_delete( &(mSettings->peer), &clients );
+        Iperf_destroy(&clients);
+        clients = NULL;
+    }
     Mutex_Unlock( &clients_mutex );
 
-    DELETE_PTR( reportstruct );
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
     EndReport( mSettings->reporthdr );
+
+#ifdef HAVE_SCHED_SETSCHEDULER
+    if (0 <= mSettings->mAffinity) {
+        cpu_set_t cpu_set;
+        int i;
+
+        CPU_ZERO(&cpu_set);
+        for (i = 0; i < CPU_SETSIZE; ++i) {
+            CPU_SET(i, &cpu_set);
+        }
+        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {
+            printf("sched_setaffinity error!!\n");
+            exit(-1);
+        }
+    }
+#endif
 } 
 // end Recv 
 
@@ -309,8 +388,8 @@ void Server::Run( void ) {
  * ------------------------------------------------------------------- */ 
 
 void Server::write_UDP_AckFIN( ) {
-
-    int rc; 
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    int rc = 0; 
 
     fd_set readSet; 
     FD_ZERO( &readSet ); 
@@ -321,10 +400,14 @@ void Server::write_UDP_AckFIN( ) {
     while ( count < 10 ) {
         count++; 
 
+        int len = sizeof(UDP_datagram) + sizeof(server_hdr);
+        char buf[300];
+        memset(buf, 0x00, sizeof(buf));
+
         UDP_datagram *UDP_Hdr;
         server_hdr *hdr;
 
-        UDP_Hdr = (UDP_datagram*) mBuf;
+        UDP_Hdr = (UDP_datagram*)buf;
 
         if ( mSettings->mBufLen > (int) ( sizeof( UDP_datagram )
                                           + sizeof( server_hdr ) ) ) {
@@ -356,10 +439,20 @@ void Server::write_UDP_AckFIN( ) {
             hdr->cntTransit   = htonl( stats->transit.totcntTransit );
 	    hdr->IPGcnt = htonl( (long) (stats->cntDatagrams / (stats->endTime - stats->startTime)));
 	    hdr->IPGsum = htonl(1);
+
+            hdr->pcpu[0]    = htonl((uint32_t)mSettings->pcpu[0]);
+            hdr->pcpu[1]    = htonl((uint32_t)mSettings->pcpu[1]);
+            hdr->pcpu[2]    = htonl((uint32_t)mSettings->pcpu[2]);
+            hdr->pcpu[3]    = htonl((uint32_t)mSettings->pcpu[3]);
         }
+        DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+        DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n", hdr->pcpu[0] , hdr->pcpu[1] , hdr->pcpu[2], hdr->pcpu[3]);
 
         // write data 
-        write( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+        ssize_t ret = write( mSettings->mSock, buf, len ); 
+        if (ret < 0) {
+            printf("%s[%d]: write error!! ret=%zd(%d)\n", __FILE__, (int)__LINE__, ret, errno);
+        }
 
         // wait until the socket is readable, or our timeout expires 
         FD_SET( mSettings->mSock, &readSet ); 
@@ -379,6 +472,7 @@ void Server::write_UDP_AckFIN( ) {
             if ( rc <= 0 ) {
                 // Connection closed or errored
                 // Stop using it.
+                printf("%s[%d]: read error!! rc=%d(%d)\n", __FILE__, (int)__LINE__, rc, errno);
                 return;
             }
         } 
@@ -388,3 +482,63 @@ void Server::write_UDP_AckFIN( ) {
 } 
 // end write_UDP_AckFIN 
 
+static void
+cpu_util(uint32_t pcpu[4])
+{
+    DEBUGP("%s[%d]: %s\n", __FILE__, (int)__LINE__, __func__);
+    static struct timeval last;
+    static clock_t clast;
+    static struct rusage rlast;
+    struct timeval temp;
+    clock_t ctemp;
+    struct rusage rtemp;
+    uint32_t diff;
+    uint32_t timediff;
+    uint32_t userdiff;
+    uint32_t systemdiff;
+
+    if (pcpu == NULL) {
+        DEBUGP("%s[%d]: %s NULL\n", __FILE__, (int)__LINE__, __func__);
+        gettimeofday(&last, NULL);
+        clast = clock();
+        getrusage(RUSAGE_SELF, &rlast);
+        return;
+    }
+
+    gettimeofday(&temp, NULL);
+    ctemp = clock();
+    getrusage(RUSAGE_SELF, &rtemp);
+
+    diff = ctemp - clast;
+    timediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -
+                (last.tv_sec * 1000000.0 + last.tv_usec));
+    userdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -
+                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));
+    systemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -
+                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));
+    pcpu[0] = diff;
+    pcpu[1] = timediff;
+    pcpu[2] = userdiff;
+    pcpu[3] = systemdiff;
+
+    g_pcpu[0] = pcpu[0];
+    g_pcpu[1] = pcpu[1];
+    g_pcpu[2] = pcpu[2];
+    g_pcpu[3] = pcpu[3];
+
+#ifdef _DEBUG
+    double dtimediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -
+                (last.tv_sec * 1000000.0 + last.tv_usec));
+    double duserdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -
+                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));
+    double dsystemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -
+                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));
+    double total = (((ctemp - clast) * 1000000.0 / CLOCKS_PER_SEC) / dtimediff) * 100;
+    double user = (duserdiff / dtimediff) * 100;
+    double sys = (dsystemdiff / dtimediff) * 100;
+    printf("%s[%d]: ", __FILE__, (int)__LINE__);
+    printf("pcpu: [0]=%u, [1]=%.5f, [2]=%.5f, [3]=%.5f\n",
+           (unsigned int)(ctemp - clast), dtimediff, duserdiff, dsystemdiff);
+    printf("user=%.1f, sys=%.1f, total=%.1f\n", user, sys, total);
+#endif
+}
diff -uprN iperf-2.0.9.orig/src/Server.cpp.~1~ iperf-2.0.9/src/Server.cpp.~1~
--- iperf-2.0.9.orig/src/Server.cpp.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Server.cpp.~1~	2017-02-11 02:06:37.194429113 +0900
@@ -0,0 +1,533 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Server.cpp
+ * by Mark Gates <mgates@nlanr.net>
+ *     Ajay Tirumala (tirumala@ncsa.uiuc.edu>.
+ * -------------------------------------------------------------------
+ * A server thread is initiated for each connection accept() returns.
+ * Handles sending and receiving data, and then closes socket.
+ * Changes to this version : The server can be run as a daemon
+ * ------------------------------------------------------------------- */
+
+#define HEADERS()
+
+#include "headers.h"
+#include "Server.hpp"
+#include "List.h"
+#include "Extractor.h"
+#include "Reporter.h"
+#include "Locale.h"
+#ifdef HAVE_SCHED_SETSCHEDULER
+#include <sched.h>
+#endif
+#ifdef HAVE_MLOCKALL
+#include <sys/mman.h>
+#endif
+
+#include <sys/time.h>
+#include <sys/resource.h>
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+static void cpu_util(uint32_t pcpu[3]);
+
+/* -------------------------------------------------------------------
+ * Stores connected socket and socket info.
+ * ------------------------------------------------------------------- */
+
+Server::Server( thread_Settings *inSettings ) {
+    mSettings = inSettings;
+    mBuf = NULL;
+
+    // initialize buffer
+    mBuf = new char[ mSettings->mBufLen ];
+    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mBuf);
+
+    FAIL_errno( mBuf == NULL, "No memory for buffer\n", mSettings );
+}
+
+/* -------------------------------------------------------------------
+ * Destructor close socket.
+ * ------------------------------------------------------------------- */
+
+Server::~Server() {
+    if ( mSettings->mSock != INVALID_SOCKET ) {
+        int rc = close( mSettings->mSock );
+        WARN_errno( rc == SOCKET_ERROR, "close" );
+        mSettings->mSock = INVALID_SOCKET;
+    }
+    if (mBuf != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mBuf);
+        DELETE_ARRAY( mBuf );
+        mBuf = NULL;
+    }
+}
+
+void Server::Sig_Int( int inSigno ) {
+}
+
+/* ------------------------------------------------------------------- 
+ * Receive data from the (connected) socket.
+ * Sends termination flag several times at the end. 
+ * Does not close the socket. 
+ * ------------------------------------------------------------------- */ 
+void Server::Run( void ) {
+    long currLen; 
+    max_size_t totLen = 0;
+    struct UDP_datagram* mBuf_UDP  = (struct UDP_datagram*) mBuf; 
+    ReportStruct *reportstruct = NULL;
+    int running;
+    bool mMode_Time = isServerModeTime( mSettings );
+
+#if HAVE_DECL_SO_TIMESTAMP
+    // Structures needed for recvmsg
+    // Use to get kernel timestamps of packets
+    struct sockaddr_storage srcaddr;
+    struct iovec iov[1];
+    iov[0].iov_base=mBuf;
+    iov[0].iov_len=mSettings->mBufLen;
+    struct msghdr message;
+    message.msg_iov=iov;
+    message.msg_iovlen=1;
+    message.msg_name=&srcaddr;
+    message.msg_namelen=sizeof(srcaddr);
+    char ctrl[CMSG_SPACE(sizeof(struct timeval))];
+    struct cmsghdr *cmsg = (struct cmsghdr *) &ctrl;
+    message.msg_control = (char *) ctrl;
+    message.msg_controllen = sizeof(ctrl);
+#endif
+
+#ifdef HAVE_SCHED_SETSCHEDULER
+    if (0 <= mSettings->mAffinity) {
+        cpu_set_t cpu_set;
+        CPU_ZERO(&cpu_set);
+        if ( mSettings->mAffinityEnd < 0) {
+            CPU_SET(mSettings->mAffinity, &cpu_set);
+        } else {
+            if (mSettings->mAffinityComma) {
+                CPU_SET(mSettings->mAffinity, &cpu_set);
+                CPU_SET(mSettings->mAffinityEnd, &cpu_set);
+            } else {
+                int i;
+                for (i = mSettings->mAffinity; i < mSettings->mAffinityEnd; ++i) {
+                    CPU_SET(i, &cpu_set);
+                }
+            }
+        }
+        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {
+            printf("sched_setaffinity error!!\n");
+            exit(-1);
+        }
+    }
+#endif
+
+    reportstruct = new ReportStruct;
+    DEBUGP("%s[%d]: new ReportStruct: %p\n", __FILE__, (int)__LINE__, reportstruct);
+    if ( reportstruct != NULL ) {
+        reportstruct->packetID = 0;
+        mSettings->reporthdr = InitReport( mSettings );
+	running=1;
+	int sorcvtimer = 0;
+	// sorcvtimer units microseconds convert to that
+	// minterval double, units seconds
+	// mAmount integer, units 10 milliseconds
+	// divide by two so timeout is 1/2 the interval
+	if (mSettings->mInterval) {
+	    sorcvtimer = (int) (mSettings->mInterval * 1e6) / 2;
+	} else if (isModeTime(mSettings)) {
+	    sorcvtimer = (mSettings->mAmount * 1000) / 2;
+	}
+	if (sorcvtimer > 0) {
+#ifdef WIN32
+            // Windows SO_RCVTIMEO uses ms
+	    DWORD timeout = (double) sorcvtimer / 1e3;
+#else
+	    struct timeval timeout;
+	    timeout.tv_sec = sorcvtimer / 1000000;
+	    timeout.tv_usec = sorcvtimer % 1000000;
+#endif
+	    if (setsockopt( mSettings->mSock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0 ) {
+		WARN_errno( mSettings->mSock == SO_RCVTIMEO, "socket" );
+	    }
+	}
+#if HAVE_DECL_SO_TIMESTAMP
+        if ( isUDP( mSettings ) ) {
+	    int timestampOn = 1;
+	    if (setsockopt(mSettings->mSock, SOL_SOCKET, SO_TIMESTAMP, (int *) &timestampOn, sizeof(timestampOn)) < 0) {
+		WARN_errno( mSettings->mSock == SO_TIMESTAMP, "socket" );
+	    }
+	}
+#endif
+#ifdef HAVE_SCHED_SETSCHEDULER
+	if ( isRealtime( mSettings ) ) {
+	    struct sched_param sp;
+	    sp.sched_priority = sched_get_priority_max(SCHED_RR); 
+	    // SCHED_OTHER, SCHED_FIFO, SCHED_RR
+	    if (sched_setscheduler(0, SCHED_RR, &sp) < 0)  {
+		perror("Client set scheduler");
+#ifdef HAVE_MLOCKALL
+	    } else if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) { 
+		// lock the threads memory
+		perror ("mlockall");
+#endif
+	    }
+	}
+#endif
+	// setup termination variables
+	if ( mMode_Time ) {
+	    mEndTime.setnow();
+	    mEndTime.add( mSettings->mAmount / 100.0 );
+	}
+
+    cpu_util(NULL);
+
+        do {
+	    reportstruct->emptyreport=0;
+#if HAVE_DECL_SO_TIMESTAMP
+            // perform read 
+            currLen = recvmsg( mSettings->mSock, &message, 0 );
+	    if (currLen <= 0) {
+		// Socket read timeout or read error
+		reportstruct->emptyreport=1;
+		gettimeofday( &(reportstruct->packetTime), NULL );
+                // End loop on 0 read or socket error
+		// except for socket read timeout
+		if (currLen == 0 ||
+#ifdef WIN32
+		    (WSAGetLastError() != WSAEWOULDBLOCK)
+#else
+		    (errno != EAGAIN && errno != EWOULDBLOCK)
+#endif		     
+		    ) {
+		    running = 0;
+		}
+		currLen= 0;
+	    }
+
+            if (!reportstruct->emptyreport && isUDP( mSettings ) ) {
+                // read the datagram ID and sentTime out of the buffer 
+                reportstruct->packetID = ntohl( mBuf_UDP->id ); 
+                reportstruct->sentTime.tv_sec = ntohl( mBuf_UDP->tv_sec  );
+                reportstruct->sentTime.tv_usec = ntohl( mBuf_UDP->tv_usec ); 
+		reportstruct->packetLen = currLen;
+		if (cmsg->cmsg_level == SOL_SOCKET &&
+		    cmsg->cmsg_type  == SCM_TIMESTAMP &&
+		    cmsg->cmsg_len   == CMSG_LEN(sizeof(struct timeval))) {
+			memcpy(&(reportstruct->packetTime), CMSG_DATA(cmsg), sizeof(struct timeval));
+		} else {
+		    gettimeofday( &(reportstruct->packetTime), NULL );
+		}
+            }
+#else
+            // perform read 
+            currLen = recv( mSettings->mSock, mBuf, mSettings->mBufLen, 0 );
+	    if (currLen <= 0) {
+		reportstruct->emptyreport=1;
+                // End loop on 0 read or socket error
+		// except for socket read timeout
+		if (currLen == 0 ||
+#ifdef WIN32
+		    (WSAGetLastError() != WSAEWOULDBLOCK)
+#else
+		    (errno != EAGAIN && errno != EWOULDBLOCK)
+#endif		     
+		    ) {
+		    running = 0;
+		}
+		currLen = 0;
+	    }
+            if (!reportstruct->emptyreport && isUDP( mSettings ) ) {
+		gettimeofday( &(reportstruct->packetTime), NULL );
+		reportstruct->packetLen = currLen;
+                // read the datagram ID and sentTime out of the buffer 
+		reportstruct->packetID = ntohl( mBuf_UDP->id ); 
+		reportstruct->sentTime.tv_sec = ntohl( mBuf_UDP->tv_sec  );
+		reportstruct->sentTime.tv_usec = ntohl( mBuf_UDP->tv_usec ); 
+            }
+#endif
+	    if (currLen) {
+		totLen += currLen;
+	    }
+            // terminate when datagram begins with negative index 
+            // the datagram ID should be correct, just negated 
+            if ( reportstruct->packetID < 0 ) {
+                reportstruct->packetID = -reportstruct->packetID;
+                currLen = -1;
+		running = 0; 
+            }
+	    if (mMode_Time && mEndTime.before( reportstruct->packetTime)) {
+		running = 0;
+	    }
+
+	    if ( isUDP (mSettings)) {
+		ReportPacket( mSettings->reporthdr, reportstruct );
+            } else {
+		// TCP case
+                reportstruct->packetLen = currLen;
+                gettimeofday( &(reportstruct->packetTime), NULL );
+                ReportPacket( mSettings->reporthdr, reportstruct );
+            }
+        } while (running); 
+                
+
+        cpu_util(mSettings->pcpu);
+        DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+        DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n",
+               mSettings->pcpu[0] , mSettings->pcpu[1] , mSettings->pcpu[2], mSettings->pcpu[3]);
+
+        // stop timing 
+        gettimeofday( &(reportstruct->packetTime), NULL );
+        
+	if ( !isUDP (mSettings)) {
+		if(0.0 == mSettings->mInterval) {
+                        reportstruct->packetLen = totLen;
+                }
+		ReportPacket( mSettings->reporthdr, reportstruct );
+	}
+        CloseReport( mSettings->reporthdr, reportstruct );
+        
+        // send a acknowledgement back only if we're NOT receiving multicast 
+        if ( isUDP( mSettings ) && !isMulticast( mSettings ) ) {
+            // send back an acknowledgement of the terminating datagram 
+            write_UDP_AckFIN( ); 
+        }
+    } else {
+        FAIL(1, "Out of memory! Closing server thread\n", mSettings);
+    }
+
+    Mutex_Lock( &clients_mutex );     
+    if (clients != NULL) {
+        DEBUGP("%s[%d]: Iperf_delete: %p\n", __FILE__, (int)__LINE__, clients);
+        //Iperf_delete( &(mSettings->peer), &clients );
+        Iperf_destroy(&clients);
+        clients = NULL;
+    }
+    Mutex_Unlock( &clients_mutex );
+
+    if (reportstruct != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, reportstruct);
+        DELETE_PTR( reportstruct );
+        reportstruct = NULL;
+    }
+    EndReport( mSettings->reporthdr );
+
+#ifdef HAVE_SCHED_SETSCHEDULER
+    if (0 <= mSettings->mAffinity) {
+        cpu_set_t cpu_set;
+        int i;
+
+        CPU_ZERO(&cpu_set);
+        for (i = 0; i < CPU_SETSIZE; ++i) {
+            CPU_SET(i, &cpu_set);
+        }
+        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {
+            printf("sched_setaffinity error!!\n");
+            exit(-1);
+        }
+    }
+#endif
+} 
+// end Recv 
+
+/* ------------------------------------------------------------------- 
+ * Send an AckFIN (a datagram acknowledging a FIN) on the socket, 
+ * then select on the socket for some time. If additional datagrams 
+ * come in, probably our AckFIN was lost and they are re-transmitted 
+ * termination datagrams, so re-transmit our AckFIN. 
+ * ------------------------------------------------------------------- */ 
+
+void Server::write_UDP_AckFIN( ) {
+
+    int rc; 
+
+    fd_set readSet; 
+    FD_ZERO( &readSet ); 
+
+    struct timeval timeout; 
+
+    int count = 0; 
+    while ( count < 10 ) {
+        count++; 
+
+        int len = sizeof(UDP_datagram) + sizeof(server_hdr);
+        char buf[300];
+        memset(buf, 0x00, sizeof(buf));
+
+        UDP_datagram *UDP_Hdr;
+        server_hdr *hdr;
+
+        UDP_Hdr = (UDP_datagram*)buf;
+
+        if ( mSettings->mBufLen > (int) ( sizeof( UDP_datagram )
+                                          + sizeof( server_hdr ) ) ) {
+            Transfer_Info *stats = GetReport( mSettings->reporthdr );
+            hdr = (server_hdr*) (UDP_Hdr+1);
+
+            hdr->flags        = htonl( HEADER_VERSION1 );
+            hdr->total_len1   = htonl( (long) (stats->TotalLen >> 32) );
+            hdr->total_len2   = htonl( (long) (stats->TotalLen & 0xFFFFFFFF) );
+            hdr->stop_sec     = htonl( (long) stats->endTime );
+            hdr->stop_usec    = htonl( (long)((stats->endTime - (long)stats->endTime) * rMillion));
+            hdr->error_cnt    = htonl( stats->cntError );
+            hdr->outorder_cnt = htonl( stats->cntOutofOrder );
+            hdr->datagrams    = htonl( stats->cntDatagrams );
+            hdr->jitter1      = htonl( (long) stats->jitter );
+            hdr->jitter2      = htonl( (long) ((stats->jitter - (long)stats->jitter) * rMillion) );
+            hdr->minTransit1  = htonl( (long) stats->transit.totminTransit );
+            hdr->minTransit2  = htonl( (long) ((stats->transit.totminTransit - (long)stats->transit.totminTransit) * rMillion) );
+            hdr->maxTransit1  = htonl( (long) stats->transit.totmaxTransit );
+            hdr->maxTransit2  = htonl( (long) ((stats->transit.totmaxTransit - (long)stats->transit.totmaxTransit) * rMillion) );
+            hdr->sumTransit1  = htonl( (long) stats->transit.totsumTransit );
+            hdr->sumTransit2  = htonl( (long) ((stats->transit.totsumTransit - (long)stats->transit.totsumTransit) * rMillion) );
+            hdr->meanTransit1  = htonl( (long) stats->transit.totmeanTransit );
+            hdr->meanTransit2  = htonl( (long) ((stats->transit.totmeanTransit - (long)stats->transit.totmeanTransit) * rMillion) );
+            hdr->m2Transit1  = htonl( (long) stats->transit.totm2Transit );
+            hdr->m2Transit2  = htonl( (long) ((stats->transit.totm2Transit - (long)stats->transit.totm2Transit) * rMillion) );
+            hdr->vdTransit1  = htonl( (long) stats->transit.totvdTransit );
+            hdr->vdTransit2  = htonl( (long) ((stats->transit.totvdTransit - (long)stats->transit.totvdTransit) * rMillion) );
+            hdr->cntTransit   = htonl( stats->transit.totcntTransit );
+	    hdr->IPGcnt = htonl( (long) (stats->cntDatagrams / (stats->endTime - stats->startTime)));
+	    hdr->IPGsum = htonl(1);
+
+            hdr->pcpu[0]    = htonl((uint32_t)mSettings->pcpu[0]);
+            hdr->pcpu[1]    = htonl((uint32_t)mSettings->pcpu[1]);
+            hdr->pcpu[2]    = htonl((uint32_t)mSettings->pcpu[2]);
+            hdr->pcpu[3]    = htonl((uint32_t)mSettings->pcpu[3]);
+        }
+        DEBUGP("%s[%d]: ", __FILE__, __LINE__);
+        DEBUGP("pcpu: [0]=%u, [1]=%u, [2]=%u, [3]=%u\n", hdr->pcpu[0] , hdr->pcpu[1] , hdr->pcpu[2], hdr->pcpu[3]);
+
+        // write data 
+        ssize_t ret = write( mSettings->mSock, buf, len ); 
+        if (ret < 0) {
+            printf("%s[%d]: write error!! ret=%zd(%d)\n", __FILE__, (int)__LINE__, ret, errno);
+        }
+
+        // wait until the socket is readable, or our timeout expires 
+        FD_SET( mSettings->mSock, &readSet ); 
+        timeout.tv_sec  = 1; 
+        timeout.tv_usec = 0; 
+
+        rc = select( mSettings->mSock+1, &readSet, NULL, NULL, &timeout ); 
+        FAIL_errno( rc == SOCKET_ERROR, "select", mSettings ); 
+
+        if ( rc == 0 ) {
+            // select timed out 
+            return; 
+        } else {
+            // socket ready to read 
+            rc = read( mSettings->mSock, mBuf, mSettings->mBufLen ); 
+            WARN_errno( rc < 0, "read" );
+            if ( rc <= 0 ) {
+                // Connection closed or errored
+                // Stop using it.
+                printf("%s[%d]: read error!! rc=%d(%d)\n", __FILE__, (int)__LINE__, rc, errno);
+                return;
+            }
+        } 
+    } 
+
+    fprintf( stderr, warn_ack_failed, mSettings->mSock, count ); 
+} 
+// end write_UDP_AckFIN 
+
+static void
+cpu_util(uint32_t pcpu[4])
+{
+    static struct timeval last;
+    static clock_t clast;
+    static struct rusage rlast;
+    struct timeval temp;
+    clock_t ctemp;
+    struct rusage rtemp;
+    uint32_t diff;
+    uint32_t timediff;
+    uint32_t userdiff;
+    uint32_t systemdiff;
+
+    if (pcpu == NULL) {
+        gettimeofday(&last, NULL);
+        clast = clock();
+        getrusage(RUSAGE_SELF, &rlast);
+        return;
+    }
+
+    gettimeofday(&temp, NULL);
+    ctemp = clock();
+    getrusage(RUSAGE_SELF, &rtemp);
+
+    diff = ctemp - clast;
+    timediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -
+                (last.tv_sec * 1000000.0 + last.tv_usec));
+    userdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -
+                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));
+    systemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -
+                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));
+    pcpu[0] = diff;
+    pcpu[1] = timediff;
+    pcpu[2] = userdiff;
+    pcpu[3] = systemdiff;
+
+#ifdef _DEBUG
+    double dtimediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -
+                (last.tv_sec * 1000000.0 + last.tv_usec));
+    double duserdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -
+                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));
+    double dsystemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -
+                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));
+    double total = (((ctemp - clast) * 1000000.0 / CLOCKS_PER_SEC) / dtimediff) * 100;
+    double user = (duserdiff / dtimediff) * 100;
+    double sys = (dsystemdiff / dtimediff) * 100;
+    printf("%s[%d]: ", __FILE__, __LINE__);
+    printf("pcpu: [0]=%u, [1]=%.5f, [2]=%.5f, [3]=%.5f\n", (ctemp - clast), dtimediff, duserdiff, dsystemdiff);
+    printf("user=%.1f, sys=%.1f, total=%.1f\n", user, sys, total);
+#endif
+}
diff -uprN iperf-2.0.9.orig/src/Settings.cpp iperf-2.0.9/src/Settings.cpp
--- iperf-2.0.9.orig/src/Settings.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/Settings.cpp	2017-02-12 21:22:40.696040632 +0900
@@ -71,6 +71,12 @@
 
 #include "gnu_getopt.h"
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 void Settings_Interpret( char option, const char *optarg, thread_Settings *mExtSettings );
 
 /* -------------------------------------------------------------------
@@ -123,6 +129,7 @@ const struct option long_options[] =
 {"ipv6_domain",      no_argument, NULL, 'V'},
 {"suggest_win_size", no_argument, NULL, 'W'},
 {"linux-congestion", required_argument, NULL, 'Z'},
+{"affinity", required_argument, NULL, 'A'},
 {0, 0, 0, 0}
 };
 
@@ -237,25 +244,39 @@ void Settings_Initialize( thread_Setting
     //main->mDomain     = kMode_IPv4;    // -V,
     //main->mSuggestWin = false;         // -W,  Suggest the window size.
 
+    main->mAffinity     = -1;
+    main->mAffinityEnd  = -1;
+    main->pcpu[0] = 0;
+    main->pcpu[1] = 0;
+    main->pcpu[2] = 0;
+    main->pcpu[3] = 0;
+
 } // end Settings
 
 void Settings_Copy( thread_Settings *from, thread_Settings **into ) {
+
     *into = new thread_Settings;
+    DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, *into);
     memcpy( *into, from, sizeof(thread_Settings) );
+
     if ( from->mHost != NULL ) {
         (*into)->mHost = new char[ strlen(from->mHost) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mHost);
         strcpy( (*into)->mHost, from->mHost );
     }
     if ( from->mOutputFileName != NULL ) {
         (*into)->mOutputFileName = new char[ strlen(from->mOutputFileName) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mOutputFileName);
         strcpy( (*into)->mOutputFileName, from->mOutputFileName );
     }
     if ( from->mLocalhost != NULL ) {
         (*into)->mLocalhost = new char[ strlen(from->mLocalhost) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mLocalhost);
         strcpy( (*into)->mLocalhost, from->mLocalhost );
     }
     if ( from->mFileName != NULL ) {
         (*into)->mFileName = new char[ strlen(from->mFileName) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mFileName);
         strcpy( (*into)->mFileName, from->mFileName );
     }
     // Zero out certain entries
@@ -269,11 +290,36 @@ void Settings_Copy( thread_Settings *fro
  * ------------------------------------------------------------------- */
 
 void Settings_Destroy( thread_Settings *mSettings) {
-    DELETE_ARRAY( mSettings->mHost      );
-    DELETE_ARRAY( mSettings->mLocalhost );
-    DELETE_ARRAY( mSettings->mFileName  );
-    DELETE_ARRAY( mSettings->mOutputFileName );
-    DELETE_PTR( mSettings );
+    if (mSettings->mHost != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, &mSettings->mHost[0]);
+        DELETE_ARRAY( mSettings->mHost      );
+        mSettings->mHost = NULL;
+    }
+
+    if (mSettings->mLocalhost != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mLocalhost);
+        DELETE_ARRAY( mSettings->mLocalhost );
+        mSettings->mLocalhost = NULL;
+   	}
+
+    if (mSettings->mFileName != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mFileName);
+        DELETE_ARRAY( mSettings->mFileName  );
+        mSettings->mFileName = NULL;
+   	}
+
+    if (mSettings->mOutputFileName != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mOutputFileName);
+        DELETE_ARRAY( mSettings->mOutputFileName );
+        mSettings->mOutputFileName = NULL;
+   	}
+
+    if (mSettings != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, mSettings);
+        DELETE_PTR( mSettings );
+        mSettings = NULL;
+   	}
+
 } // end ~Settings
 
 /* -------------------------------------------------------------------
@@ -320,6 +366,9 @@ void Settings_Interpret( char option, co
     char *results = NULL;
     max_size_t theNum;
     char suffix='\0';
+    char *endptr = NULL;
+    char *cparg = (char *)optarg;
+    char *comma = NULL;
 
     switch ( option ) {
         case '1': // Single Client
@@ -329,9 +378,9 @@ void Settings_Interpret( char option, co
             Settings_GetLowerCaseArg(optarg,outarg);
 	    // scan for PPS units, just look for 'p' as that's good enough
 #ifdef HAVE_QUAD_SUPPORT
-	    sscanf(outarg, "%llu%c", &theNum, &suffix );
+        sscanf(outarg, "%lu%c", (unsigned long*)&theNum, &suffix );
 #else
-	    sscanf(outarg, "%lu%c", &theNum, &suffix );
+	    sscanf(outarg, "%lu%c", (unsigned long*)&theNum, &suffix );
 #endif
 	    if (suffix == 'p') {
 		mExtSettings->mUDPRateUnits = kRate_PPS;
@@ -350,6 +399,8 @@ void Settings_Interpret( char option, co
 
         case 'c': // client mode w/ server host to connect to
             mExtSettings->mHost = new char[ strlen( optarg ) + 1 ];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mHost);
+
             strcpy( mExtSettings->mHost, optarg );
 
             if ( mExtSettings->mThreadMode == kMode_Unknown ) {
@@ -443,6 +494,7 @@ void Settings_Interpret( char option, co
         case 'o' : // output the report and other messages into the file
             unsetSTDOUT( mExtSettings );
             mExtSettings->mOutputFileName = new char[strlen(optarg)+1];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mOutputFileName);
             strcpy( mExtSettings->mOutputFileName, optarg);
             break;
 
@@ -563,19 +615,26 @@ void Settings_Interpret( char option, co
             // more esoteric options
         case 'B': // specify bind address
 	    parsedopts = new char[ strlen( optarg ) + 1 ];
+   	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, parsedopts);
 	    strcpy(parsedopts, optarg );
 	    results = strtok(parsedopts, ":");
 	    if (results != NULL) {
 	      mExtSettings->mLocalhost = new char[ strlen( results ) + 1 ];
+     	  DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mLocalhost);
 	      strcpy( mExtSettings->mLocalhost, results );
 	      results = strtok(NULL, ":");
 	      if (results != NULL) 
 		mExtSettings->mBindPort = atoi(results);
 	    } else {  
 	      mExtSettings->mLocalhost = new char[ strlen( optarg ) + 1 ];
+          DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mLocalhost);
 	      strcpy( mExtSettings->mLocalhost, optarg );
 	    }
-	    delete parsedopts;
+        if (parsedopts != NULL) {
+           DEBUGP("%s[%d]: delete: %p\n", __FILE__, (int)__LINE__, parsedopts);
+           delete parsedopts;
+            parsedopts = NULL;
+        }
             // Test for Multicast
             iperf_sockaddr temp;
             SockAddr_setHostname( mExtSettings->mLocalhost, &temp,
@@ -607,6 +666,7 @@ void Settings_Interpret( char option, co
 
             setFileInput( mExtSettings );
             mExtSettings->mFileName = new char[strlen(optarg)+1];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mFileName);
             strcpy( mExtSettings->mFileName, optarg);
             break;
 
@@ -619,6 +679,7 @@ void Settings_Interpret( char option, co
             setFileInput( mExtSettings );
             setSTDIN( mExtSettings );
             mExtSettings->mFileName = new char[strlen("<stdin>")+1];
+       	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mFileName);
             strcpy( mExtSettings->mFileName,"<stdin>");
             break;
 
@@ -701,12 +762,46 @@ void Settings_Interpret( char option, co
 #ifdef TCP_CONGESTION
 	    setCongestionControl( mExtSettings );
 	    mExtSettings->mCongestion = new char[strlen(optarg)+1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mCongestion);
 	    strcpy( mExtSettings->mCongestion, optarg);
 #else
             fprintf( stderr, "The -Z option is not available on this operating system\n");
 #endif
 	    break;
 
+        case 'A':
+#ifdef HAVE_SCHED_SETSCHEDULER
+            mExtSettings->mAffinity = strtol(optarg, &endptr, 0);
+            if (endptr == optarg ||
+                mExtSettings->mAffinity < 0 || mExtSettings->mAffinity > 1024) {
+                //i_errno = IEAFFINITY;
+                exit(-1);
+            }
+
+            comma = strchr(cparg, ',');
+            if (comma != NULL) {
+                mExtSettings->mAffinityEnd = atoi(comma+1);
+                if (mExtSettings->mAffinityEnd < 0 || mExtSettings->mAffinityEnd > 1024) {
+                    //i_errno = IEAFFINITY;
+                    exit(-1);
+                }
+                mExtSettings->mAffinityComma = 1;
+            } else {
+                comma = strchr(cparg, '-');
+                if (comma != NULL) {
+                    mExtSettings->mAffinityEnd = atoi(comma+1);
+                    if (mExtSettings->mAffinityEnd < 0 || mExtSettings->mAffinityEnd > 1024) {
+                        //i_errno = IEAFFINITY;
+                        exit(-1);
+                    }
+                    mExtSettings->mAffinityComma = 0;
+                }
+            }
+#else
+            printf("Don't have sched_setscheduler\n");
+            printf("CPU affinity is not support\n");
+            exit(-1);
+#endif
         default: // ignore unknown
             break;
     }
@@ -744,6 +839,8 @@ void Settings_GenerateListenerSettings(
     if ( !isCompat( client ) && 
          (client->mMode == kTest_DualTest || client->mMode == kTest_TradeOff) ) {
         *listener = new thread_Settings;
+        DEBUGP("%s[%d]: new Client: %p\n", __FILE__, (int)__LINE__, *listener);
+
         memcpy(*listener, client, sizeof( thread_Settings ));
         setCompat( (*listener) );
         unsetDaemon( (*listener) );
@@ -758,14 +855,15 @@ void Settings_GenerateListenerSettings(
         (*listener)->mOutputFileName = NULL;
         (*listener)->mMode       = kTest_Normal;
         (*listener)->mThreadMode = kMode_Listener;
-        if ( client->mHost != NULL ) {
-            (*listener)->mHost = new char[strlen( client->mHost ) + 1];
-            strcpy( (*listener)->mHost, client->mHost );
-        }
-        if ( client->mLocalhost != NULL ) {
-            (*listener)->mLocalhost = new char[strlen( client->mLocalhost ) + 1];
-            strcpy( (*listener)->mLocalhost, client->mLocalhost );
-        }
+
+        (*listener)->mHost = new char[strlen( client->mHost ) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*listener)->mHost);
+        strcpy( (*listener)->mHost, client->mHost );
+
+        (*listener)->mLocalhost = new char[strlen( client->mLocalhost ) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*listener)->mLocalhost);
+        strcpy( (*listener)->mLocalhost, client->mLocalhost );
+
     } else {
         *listener = NULL;
     }
@@ -786,6 +884,8 @@ void Settings_GenerateClientSettings( th
     int flags = ntohl(hdr->flags);
     if ( (flags & HEADER_VERSION1) != 0 ) {
         *client = new thread_Settings;
+        DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, *client);
+
         memcpy(*client, server, sizeof( thread_Settings ));
         setCompat( (*client) );
         (*client)->mTID = thread_zeroid();
@@ -822,9 +922,12 @@ void Settings_GenerateClientSettings( th
         (*client)->mThreadMode = kMode_Client;
         if ( server->mLocalhost != NULL ) {
             (*client)->mLocalhost = new char[strlen( server->mLocalhost ) + 1];
+       	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*client)->mLocalhost);
             strcpy( (*client)->mLocalhost, server->mLocalhost );
         }
         (*client)->mHost = new char[REPORT_ADDRLEN];
+   	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*client)->mHost);
+
         if ( ((sockaddr*)&server->peer)->sa_family == AF_INET ) {
             inet_ntop( AF_INET, &((sockaddr_in*)&server->peer)->sin_addr, 
                        (*client)->mHost, REPORT_ADDRLEN);
@@ -847,6 +950,8 @@ void Settings_GenerateClientSettings( th
  * This should be an inverse operation of GenerateSpeakerSettings
  */
 void Settings_GenerateClientHdr( thread_Settings *client, client_hdr *hdr ) {
+    DEBUGP("client=%p, hdr=%p\n", client, hdr);
+
     if ( client->mMode != kTest_Normal ) {
         hdr->flags  = htonl(HEADER_VERSION1);
     } else {
diff -uprN iperf-2.0.9.orig/src/Settings.cpp.~1~ iperf-2.0.9/src/Settings.cpp.~1~
--- iperf-2.0.9.orig/src/Settings.cpp.~1~	1970-01-01 09:00:00.000000000 +0900
+++ iperf-2.0.9/src/Settings.cpp.~1~	2017-02-11 02:06:37.198429133 +0900
@@ -0,0 +1,983 @@
+/*--------------------------------------------------------------- 
+ * Copyright (c) 1999,2000,2001,2002,2003                              
+ * The Board of Trustees of the University of Illinois            
+ * All Rights Reserved.                                           
+ *--------------------------------------------------------------- 
+ * Permission is hereby granted, free of charge, to any person    
+ * obtaining a copy of this software (Iperf) and associated       
+ * documentation files (the "Software"), to deal in the Software  
+ * without restriction, including without limitation the          
+ * rights to use, copy, modify, merge, publish, distribute,        
+ * sublicense, and/or sell copies of the Software, and to permit     
+ * persons to whom the Software is furnished to do
+ * so, subject to the following conditions: 
+ *
+ *     
+ * Redistributions of source code must retain the above 
+ * copyright notice, this list of conditions and 
+ * the following disclaimers. 
+ *
+ *     
+ * Redistributions in binary form must reproduce the above 
+ * copyright notice, this list of conditions and the following 
+ * disclaimers in the documentation and/or other materials 
+ * provided with the distribution. 
+ * 
+ *     
+ * Neither the names of the University of Illinois, NCSA, 
+ * nor the names of its contributors may be used to endorse 
+ * or promote products derived from this Software without
+ * specific prior written permission. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT 
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * ________________________________________________________________
+ * National Laboratory for Applied Network Research 
+ * National Center for Supercomputing Applications 
+ * University of Illinois at Urbana-Champaign 
+ * http://www.ncsa.uiuc.edu
+ * ________________________________________________________________ 
+ *
+ * Settings.cpp
+ * by Mark Gates <mgates@nlanr.net>
+ * & Ajay Tirumala <tirumala@ncsa.uiuc.edu>
+ * -------------------------------------------------------------------
+ * Stores and parses the initial values for all the global variables.
+ * -------------------------------------------------------------------
+ * headers
+ * uses
+ *   <stdlib.h>
+ *   <stdio.h>
+ *   <string.h>
+ *
+ *   <unistd.h>
+ * ------------------------------------------------------------------- */
+
+#define HEADERS()
+
+#include "headers.h"
+
+#include "Settings.hpp"
+#include "Locale.h"
+#include "SocketAddr.h"
+
+#include "util.h"
+
+#include "gnu_getopt.h"
+
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
+void Settings_Interpret( char option, const char *optarg, thread_Settings *mExtSettings );
+
+/* -------------------------------------------------------------------
+ * command line options
+ *
+ * The option struct essentially maps a long option name (--foobar)
+ * or environment variable ($FOOBAR) to its short option char (f).
+ * ------------------------------------------------------------------- */
+#define LONG_OPTIONS()
+
+const struct option long_options[] =
+{
+{"singleclient",     no_argument, NULL, '1'},
+{"bandwidth",  required_argument, NULL, 'b'},
+{"client",     required_argument, NULL, 'c'},
+{"dualtest",         no_argument, NULL, 'd'},
+{"enhancedreports",   no_argument, NULL, 'e'},
+{"format",     required_argument, NULL, 'f'},
+{"help",             no_argument, NULL, 'h'},
+{"interval",   required_argument, NULL, 'i'},
+{"len",        required_argument, NULL, 'l'},
+{"print_mss",        no_argument, NULL, 'm'},
+{"num",        required_argument, NULL, 'n'},
+{"output",     required_argument, NULL, 'o'},
+{"port",       required_argument, NULL, 'p'},
+{"tradeoff",         no_argument, NULL, 'r'},
+{"server",           no_argument, NULL, 's'},
+{"time",       required_argument, NULL, 't'},
+{"udp",              no_argument, NULL, 'u'},
+{"version",          no_argument, NULL, 'v'},
+{"window",     required_argument, NULL, 'w'},
+{"reportexclude", required_argument, NULL, 'x'},
+{"reportstyle",required_argument, NULL, 'y'},
+{"realtime",         no_argument, NULL, 'z'},
+
+// more esoteric options
+{"bind",       required_argument, NULL, 'B'},
+{"compatibility",    no_argument, NULL, 'C'},
+{"daemon",           no_argument, NULL, 'D'},
+{"file_input", required_argument, NULL, 'F'},
+{"stdin_input",      no_argument, NULL, 'I'},
+{"mss",        required_argument, NULL, 'M'},
+{"nodelay",          no_argument, NULL, 'N'},
+{"listenport", required_argument, NULL, 'L'},
+{"parallel",   required_argument, NULL, 'P'},
+{"remove",           no_argument, NULL, 'R'},
+{"tos",        required_argument, NULL, 'S'},
+{"ttl",        required_argument, NULL, 'T'},
+{"single_udp",       no_argument, NULL, 'U'},
+{"ipv6_domain",      no_argument, NULL, 'V'},
+{"suggest_win_size", no_argument, NULL, 'W'},
+{"linux-congestion", required_argument, NULL, 'Z'},
+{"affinity", required_argument, NULL, 'A'},
+{0, 0, 0, 0}
+};
+
+#define ENV_OPTIONS()
+
+const struct option env_options[] =
+{
+{"IPERF_SINGLECLIENT",     no_argument, NULL, '1'},
+{"IPERF_BANDWIDTH",  required_argument, NULL, 'b'},
+{"IPERF_CLIENT",     required_argument, NULL, 'c'},
+{"IPERF_DUALTEST",         no_argument, NULL, 'd'},
+{"IPERF_ENHANCEDREPORTS",  no_argument, NULL, 'e'},
+{"IPERF_FORMAT",     required_argument, NULL, 'f'},
+// skip help
+{"IPERF_INTERVAL",   required_argument, NULL, 'i'},
+{"IPERF_LEN",        required_argument, NULL, 'l'},
+{"IPERF_PRINT_MSS",        no_argument, NULL, 'm'},
+{"IPERF_NUM",        required_argument, NULL, 'n'},
+{"IPERF_PORT",       required_argument, NULL, 'p'},
+{"IPERF_TRADEOFF",         no_argument, NULL, 'r'},
+{"IPERF_SERVER",           no_argument, NULL, 's'},
+{"IPERF_TIME",       required_argument, NULL, 't'},
+{"IPERF_UDP",              no_argument, NULL, 'u'},
+// skip version
+{"TCP_WINDOW_SIZE",  required_argument, NULL, 'w'},
+{"IPERF_REPORTEXCLUDE", required_argument, NULL, 'x'},
+{"IPERF_REPORTSTYLE",required_argument, NULL, 'y'},
+
+// more esoteric options
+{"IPERF_BIND",       required_argument, NULL, 'B'},
+{"IPERF_COMPAT",           no_argument, NULL, 'C'},
+{"IPERF_DAEMON",           no_argument, NULL, 'D'},
+{"IPERF_FILE_INPUT", required_argument, NULL, 'F'},
+{"IPERF_STDIN_INPUT",      no_argument, NULL, 'I'},
+{"IPERF_MSS",        required_argument, NULL, 'M'},
+{"IPERF_NODELAY",          no_argument, NULL, 'N'},
+{"IPERF_LISTENPORT", required_argument, NULL, 'L'},
+{"IPERF_PARALLEL",   required_argument, NULL, 'P'},
+{"IPERF_TOS",        required_argument, NULL, 'S'},
+{"IPERF_TTL",        required_argument, NULL, 'T'},
+{"IPERF_SINGLE_UDP",       no_argument, NULL, 'U'},
+{"IPERF_IPV6_DOMAIN",      no_argument, NULL, 'V'},
+{"IPERF_SUGGEST_WIN_SIZE", required_argument, NULL, 'W'},
+{"IPERF_CONGESTION_CONTROL",  required_argument, NULL, 'Z'},
+{0, 0, 0, 0}
+};
+
+#define SHORT_OPTIONS()
+
+const char short_options[] = "1b:c:def:hi:l:mn:o:p:rst:uvw:x:y:zB:CDF:IL:M:NP:RS:T:UVWZ:";
+
+/* -------------------------------------------------------------------
+ * defaults
+ * ------------------------------------------------------------------- */
+#define DEFAULTS()
+
+const long kDefault_UDPRate = 1024 * 1024; // -u  if set, 1 Mbit/sec
+const int  kDefault_UDPBufLen = 1470;      // -u  if set, read/write 1470 bytes
+// 1470 bytes is small enough to be sending one packet per datagram on ethernet
+
+// 1450 bytes is small enough to be sending one packet per datagram on ethernet
+//  **** with IPv6 ****
+
+/* -------------------------------------------------------------------
+ * Initialize all settings to defaults.
+ * ------------------------------------------------------------------- */
+
+void Settings_Initialize( thread_Settings *main ) {
+    // Everything defaults to zero or NULL with
+    // this memset. Only need to set non-zero values
+    // below.
+    memset( main, 0, sizeof(thread_Settings) );
+    main->mSock = INVALID_SOCKET;
+    main->mReportMode = kReport_Default;
+    // option, defaults
+    main->flags         = FLAG_MODETIME | FLAG_STDOUT; // Default time and stdout
+    //main->mUDPRate      = 0;           // -b,  ie. TCP mode
+    main->mUDPRateUnits = kRate_BW;
+    //main->mHost         = NULL;        // -c,  none, required for client
+    main->mMode         = kTest_Normal;  // -d,  mMode == kTest_DualTest
+    main->mFormat       = 'a';           // -f,  adaptive bits
+    // skip help                         // -h,
+    //main->mBufLenSet  = false;         // -l,	
+    main->mBufLen       = 128 * 1024;      // -l,  8 Kbyte
+    //main->mInterval     = 0;           // -i,  ie. no periodic bw reports
+    //main->mPrintMSS   = false;         // -m,  don't print MSS
+    // mAmount is time also              // -n,  N/A
+    //main->mOutputFileName = NULL;      // -o,  filename
+    main->mPort         = 5001;          // -p,  ttcp port
+    main->mBindPort     = 0;             // -B,  default port for bind
+    // mMode    = kTest_Normal;          // -r,  mMode == kTest_TradeOff
+    main->mThreadMode   = kMode_Unknown; // -s,  or -c, none
+    main->mAmount       = 1000;          // -t,  10 seconds
+    // mUDPRate > 0 means UDP            // -u,  N/A, see kDefault_UDPRate
+    // skip version                      // -v,
+    //main->mTCPWin       = 0;           // -w,  ie. don't set window
+
+    // more esoteric options
+    //main->mLocalhost    = NULL;        // -B,  none
+    //main->mCompat     = false;         // -C,  run in Compatibility mode
+    //main->mDaemon     = false;         // -D,  run as a daemon
+    //main->mFileInput  = false;         // -F,
+    //main->mFileName     = NULL;        // -F,  filename 
+    //main->mStdin      = false;         // -I,  default not stdin
+    //main->mListenPort   = 0;           // -L,  listen port
+    //main->mMSS          = 0;           // -M,  ie. don't set MSS
+    //main->mNodelay    = false;         // -N,  don't set nodelay
+    //main->mThreads      = 0;           // -P,
+    //main->mRemoveService = false;      // -R,
+    //main->mTOS          = 0;           // -S,  ie. don't set type of service
+    main->mTTL          = 1;             // -T,  link-local TTL
+    //main->mDomain     = kMode_IPv4;    // -V,
+    //main->mSuggestWin = false;         // -W,  Suggest the window size.
+
+    main->mAffinity     = -1;
+    main->mAffinityEnd  = -1;
+    main->pcpu[0] = 0;
+    main->pcpu[1] = 0;
+    main->pcpu[2] = 0;
+    main->pcpu[3] = 0;
+
+} // end Settings
+
+void Settings_Copy( thread_Settings *from, thread_Settings **into ) {
+
+    *into = new thread_Settings;
+    DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, *into);
+    memcpy( *into, from, sizeof(thread_Settings) );
+
+    if ( from->mHost != NULL ) {
+        (*into)->mHost = new char[ strlen(from->mHost) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mHost);
+        strcpy( (*into)->mHost, from->mHost );
+    }
+    if ( from->mOutputFileName != NULL ) {
+        (*into)->mOutputFileName = new char[ strlen(from->mOutputFileName) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mOutputFileName);
+        strcpy( (*into)->mOutputFileName, from->mOutputFileName );
+    }
+    if ( from->mLocalhost != NULL ) {
+        (*into)->mLocalhost = new char[ strlen(from->mLocalhost) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mLocalhost);
+        strcpy( (*into)->mLocalhost, from->mLocalhost );
+    }
+    if ( from->mFileName != NULL ) {
+        (*into)->mFileName = new char[ strlen(from->mFileName) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*into)->mFileName);
+        strcpy( (*into)->mFileName, from->mFileName );
+    }
+    // Zero out certain entries
+    (*into)->mTID = thread_zeroid();
+    (*into)->runNext = NULL;
+    (*into)->runNow = NULL;
+}
+
+/* -------------------------------------------------------------------
+ * Delete memory: Does not clean up open file pointers or ptr_parents
+ * ------------------------------------------------------------------- */
+
+void Settings_Destroy( thread_Settings *mSettings) {
+    if (mSettings->mHost != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, &mSettings->mHost[0]);
+        DELETE_ARRAY( mSettings->mHost      );
+        mSettings->mHost = NULL;
+    }
+
+    if (mSettings->mLocalhost != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mLocalhost);
+        DELETE_ARRAY( mSettings->mLocalhost );
+        mSettings->mLocalhost = NULL;
+   	}
+
+    if (mSettings->mFileName != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mFileName);
+        DELETE_ARRAY( mSettings->mFileName  );
+        mSettings->mFileName = NULL;
+   	}
+
+    if (mSettings->mOutputFileName != NULL) {
+        DEBUGP("%s[%d]: DELETE_ARRAY: %p\n", __FILE__, (int)__LINE__, mSettings->mOutputFileName);
+        DELETE_ARRAY( mSettings->mOutputFileName );
+        mSettings->mOutputFileName = NULL;
+   	}
+
+    if (mSettings != NULL) {
+        DEBUGP("%s[%d]: DELETE_PTR: %p\n", __FILE__, (int)__LINE__, mSettings);
+        DELETE_PTR( mSettings );
+        mSettings = NULL;
+   	}
+
+} // end ~Settings
+
+/* -------------------------------------------------------------------
+ * Parses settings from user's environment variables.
+ * ------------------------------------------------------------------- */
+void Settings_ParseEnvironment( thread_Settings *mSettings ) {
+    char *theVariable;
+
+    int i = 0;
+    while ( env_options[i].name != NULL ) {
+        theVariable = getenv( env_options[i].name );
+        if ( theVariable != NULL ) {
+            Settings_Interpret( env_options[i].val, theVariable, mSettings );
+        }
+        i++;
+    }
+} // end ParseEnvironment
+
+/* -------------------------------------------------------------------
+ * Parse settings from app's command line.
+ * ------------------------------------------------------------------- */
+
+void Settings_ParseCommandLine( int argc, char **argv, thread_Settings *mSettings ) {
+    int option;
+    while ( (option =
+             gnu_getopt_long( argc, argv, short_options,
+                              long_options, NULL )) != EOF ) {
+        Settings_Interpret( option, gnu_optarg, mSettings );
+    }
+
+    for ( int i = gnu_optind; i < argc; i++ ) {
+        fprintf( stderr, "%s: ignoring extra argument -- %s\n", argv[0], argv[i] );
+    }
+} // end ParseCommandLine
+
+/* -------------------------------------------------------------------
+ * Interpret individual options, either from the command line
+ * or from environment variables.
+ * ------------------------------------------------------------------- */
+
+void Settings_Interpret( char option, const char *optarg, thread_Settings *mExtSettings ) {
+    char outarg[100];
+    char *parsedopts;
+    char *results = NULL;
+    max_size_t theNum;
+    char suffix='\0';
+    char *endptr = NULL;
+    char *cparg = (char *)optarg;
+    char *comma = NULL;
+
+    switch ( option ) {
+        case '1': // Single Client
+            setSingleClient( mExtSettings );
+            break;
+        case 'b': // UDP bandwidth
+            Settings_GetLowerCaseArg(optarg,outarg);
+	    // scan for PPS units, just look for 'p' as that's good enough
+#ifdef HAVE_QUAD_SUPPORT
+        sscanf(outarg, "%lu%c", &theNum, &suffix );
+#else
+	    sscanf(outarg, "%lu%c", &theNum, &suffix );
+#endif
+	    if (suffix == 'p') {
+		mExtSettings->mUDPRateUnits = kRate_PPS;
+		mExtSettings->mUDPRate = theNum;
+	    } else {		
+		mExtSettings->mUDPRateUnits = kRate_BW;
+		mExtSettings->mUDPRate = byte_atoi(outarg);
+	    }
+            setBWSet( mExtSettings );
+            // if -l has already been processed, mBufLenSet is true
+            // so don't overwrite that value.
+            if ( !isBuflenSet( mExtSettings ) ) {
+                mExtSettings->mBufLen = kDefault_UDPBufLen;
+            }
+            break;
+
+        case 'c': // client mode w/ server host to connect to
+            mExtSettings->mHost = new char[ strlen( optarg ) + 1 ];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mHost);
+
+            strcpy( mExtSettings->mHost, optarg );
+
+            if ( mExtSettings->mThreadMode == kMode_Unknown ) {
+                // Test for Multicast
+                iperf_sockaddr temp;
+                SockAddr_setHostname( mExtSettings->mHost, &temp,
+                                      (isIPV6( mExtSettings ) ? 1 : 0 ));
+                if ( SockAddr_isMulticast( &temp ) ) {
+                    setMulticast( mExtSettings );
+                }
+                mExtSettings->mThreadMode = kMode_Client;
+                mExtSettings->mThreads = 1;
+            }
+            break;
+
+        case 'd': // Dual-test Mode
+            if ( mExtSettings->mThreadMode != kMode_Client ) {
+                fprintf( stderr, warn_invalid_server_option, option );
+                break;
+            }
+            if ( isCompat( mExtSettings ) ) {
+                fprintf( stderr, warn_invalid_compatibility_option, option );
+            }
+#ifdef HAVE_THREAD
+            mExtSettings->mMode = kTest_DualTest;
+#else
+            fprintf( stderr, warn_invalid_single_threaded, option );
+            mExtSettings->mMode = kTest_TradeOff;
+#endif
+            break;
+        case 'e': // Use enhanced reports 
+            setEnhanced( mExtSettings );
+            break;
+        case 'f': // format to print in
+            mExtSettings->mFormat = (*optarg);
+            break;
+
+        case 'h': // print help and exit
+	    fprintf(stderr, "%s", usage_long1);
+            fprintf(stderr, "%s", usage_long2);
+            exit(1);
+            break;
+
+        case 'i': // specify interval between periodic bw reports
+            mExtSettings->mInterval = atof( optarg );
+            if ( mExtSettings->mInterval < SMALLEST_INTERVAL ) {
+                fprintf (stderr, report_interval_small, mExtSettings->mInterval);
+                mExtSettings->mInterval = SMALLEST_INTERVAL;
+            }
+            if ( mExtSettings->mInterval < 0.5 ) {
+		setEnhanced( mExtSettings );
+	    }
+            break;
+
+        case 'l': // length of each buffer
+            Settings_GetUpperCaseArg(optarg,outarg);
+            mExtSettings->mBufLen = byte_atoi( outarg );
+            setBuflenSet( mExtSettings );
+            if ( !isUDP( mExtSettings ) ) {
+                 if ( mExtSettings->mBufLen < (int) sizeof( client_hdr ) &&
+                      !isCompat( mExtSettings ) ) {
+                    setCompat( mExtSettings );
+                    fprintf( stderr, warn_implied_compatibility, option );
+                 }
+            } else {
+                if ( mExtSettings->mBufLen < (int) sizeof( UDP_datagram ) ) {
+                    mExtSettings->mBufLen = sizeof( UDP_datagram );
+                    fprintf( stderr, warn_buffer_too_small, mExtSettings->mBufLen );
+                }
+                if ( !isCompat( mExtSettings ) &&
+                            mExtSettings->mBufLen < (int) ( sizeof( UDP_datagram )
+                            + sizeof( client_hdr ) ) ) {
+                    setCompat( mExtSettings );
+                    fprintf( stderr, warn_implied_compatibility, option );
+                }
+            }
+
+            break;
+
+        case 'm': // print TCP MSS
+            setPrintMSS( mExtSettings );
+            break;
+
+        case 'n': // bytes of data
+            // amount mode (instead of time mode)
+            unsetModeTime( mExtSettings );
+            Settings_GetUpperCaseArg(optarg,outarg);
+            mExtSettings->mAmount = byte_atoi( outarg );
+            break;
+
+        case 'o' : // output the report and other messages into the file
+            unsetSTDOUT( mExtSettings );
+            mExtSettings->mOutputFileName = new char[strlen(optarg)+1];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mOutputFileName);
+            strcpy( mExtSettings->mOutputFileName, optarg);
+            break;
+
+        case 'p': // server port
+            mExtSettings->mPort = atoi( optarg );
+            break;
+
+        case 'r': // test mode tradeoff
+            if ( mExtSettings->mThreadMode != kMode_Client ) {
+                fprintf( stderr, warn_invalid_server_option, option );
+                break;
+            }
+            if ( isCompat( mExtSettings ) ) {
+                fprintf( stderr, warn_invalid_compatibility_option, option );
+            }
+
+            mExtSettings->mMode = kTest_TradeOff;
+            break;
+
+        case 's': // server mode
+            if ( mExtSettings->mThreadMode != kMode_Unknown ) {
+                fprintf( stderr, warn_invalid_client_option, option );
+                break;
+            }
+
+            mExtSettings->mThreadMode = kMode_Listener;
+            break;
+
+        case 't': // seconds to run the client, server, listener
+            // time mode (instead of amount mode), units is 10 ms
+            setModeTime( mExtSettings );
+            setServerModeTime( mExtSettings );
+            mExtSettings->mAmount = (int) (atof( optarg ) * 100.0);
+            break;
+
+        case 'u': // UDP instead of TCP
+            // if -b has already been processed, UDP rate will
+            // already be non-zero, so don't overwrite that value
+            if ( !isUDP( mExtSettings ) ) {
+                setUDP( mExtSettings );
+		if ( !isBWSet( mExtSettings ) )
+		    mExtSettings->mUDPRate = kDefault_UDPRate;
+            }
+
+            // if -l has already been processed, mBufLenSet is true
+            // so don't overwrite that value.
+            if ( !isBuflenSet( mExtSettings ) ) {
+                mExtSettings->mBufLen = kDefault_UDPBufLen;
+            } else if ( mExtSettings->mBufLen < (int) ( sizeof( UDP_datagram ) 
+                        + sizeof( client_hdr ) ) &&
+                        !isCompat( mExtSettings ) ) {
+                setCompat( mExtSettings );
+                fprintf( stderr, warn_implied_compatibility, option );
+            }
+            break;
+
+        case 'v': // print version and exit
+	    fprintf( stderr, "%s", version );
+            exit(1);
+            break;
+
+        case 'w': // TCP window size (socket buffer size)
+            Settings_GetUpperCaseArg(optarg,outarg);
+            mExtSettings->mTCPWin = byte_atoi(outarg);
+
+            if ( mExtSettings->mTCPWin < 2048 ) {
+                fprintf( stderr, warn_window_small, mExtSettings->mTCPWin );
+            }
+            break;
+
+        case 'x': // Limit Reports
+            while ( *optarg != '\0' ) {
+                switch ( *optarg ) {
+                    case 's':
+                    case 'S':
+                        setNoSettReport( mExtSettings );
+                        break;
+                    case 'c':
+                    case 'C':
+                        setNoConnReport( mExtSettings );
+                        break;
+                    case 'd':
+                    case 'D':
+                        setNoDataReport( mExtSettings );
+                        break;
+                    case 'v':
+                    case 'V':
+                        setNoServReport( mExtSettings );
+                        break;
+                    case 'm':
+                    case 'M':
+                        setNoMultReport( mExtSettings );
+                        break;
+                    default:
+                        fprintf(stderr, warn_invalid_report, *optarg);
+                }
+                optarg++;
+            }
+            break;
+#ifdef HAVE_SCHED_SETSCHEDULER
+        case 'z': // Use realtime scheduling
+	    setRealtime( mExtSettings );
+            break;
+#endif
+
+        case 'y': // Reporting Style
+            switch ( *optarg ) {
+                case 'c':
+                case 'C':
+                    mExtSettings->mReportMode = kReport_CSV;
+                    break;
+                default:
+                    fprintf( stderr, warn_invalid_report_style, optarg );
+            }
+            break;
+
+
+            // more esoteric options
+        case 'B': // specify bind address
+	    parsedopts = new char[ strlen( optarg ) + 1 ];
+   	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, parsedopts);
+	    strcpy(parsedopts, optarg );
+	    results = strtok(parsedopts, ":");
+	    if (results != NULL) {
+	      mExtSettings->mLocalhost = new char[ strlen( results ) + 1 ];
+     	  DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mLocalhost);
+	      strcpy( mExtSettings->mLocalhost, results );
+	      results = strtok(NULL, ":");
+	      if (results != NULL) 
+		mExtSettings->mBindPort = atoi(results);
+	    } else {  
+	      mExtSettings->mLocalhost = new char[ strlen( optarg ) + 1 ];
+          DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mLocalhost);
+	      strcpy( mExtSettings->mLocalhost, optarg );
+	    }
+        if (parsedopts != NULL) {
+           DEBUGP("%s[%d]: delete: %p\n", __FILE__, (int)__LINE__, parsedopts);
+           delete parsedopts;
+            parsedopts = NULL;
+        }
+            // Test for Multicast
+            iperf_sockaddr temp;
+            SockAddr_setHostname( mExtSettings->mLocalhost, &temp,
+                                  (isIPV6( mExtSettings ) ? 1 : 0 ));
+            if ( SockAddr_isMulticast( &temp ) ) {
+                setMulticast( mExtSettings );
+            }
+            break;
+
+        case 'C': // Run in Compatibility Mode
+            setCompat( mExtSettings );
+            if ( mExtSettings->mMode != kTest_Normal ) {
+                fprintf( stderr, warn_invalid_compatibility_option,
+                        ( mExtSettings->mMode == kTest_DualTest ?
+                          'd' : 'r' ) );
+                mExtSettings->mMode = kTest_Normal;
+            }
+            break;
+
+        case 'D': // Run as a daemon
+            setDaemon( mExtSettings );
+            break;
+
+        case 'F' : // Get the input for the data stream from a file
+            if ( mExtSettings->mThreadMode != kMode_Client ) {
+                fprintf( stderr, warn_invalid_server_option, option );
+                break;
+            }
+
+            setFileInput( mExtSettings );
+            mExtSettings->mFileName = new char[strlen(optarg)+1];
+            DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mFileName);
+            strcpy( mExtSettings->mFileName, optarg);
+            break;
+
+        case 'I' : // Set the stdin as the input source
+            if ( mExtSettings->mThreadMode != kMode_Client ) {
+                fprintf( stderr, warn_invalid_server_option, option );
+                break;
+            }
+
+            setFileInput( mExtSettings );
+            setSTDIN( mExtSettings );
+            mExtSettings->mFileName = new char[strlen("<stdin>")+1];
+       	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mFileName);
+            strcpy( mExtSettings->mFileName,"<stdin>");
+            break;
+
+        case 'L': // Listen Port (bidirectional testing client-side)
+            if ( mExtSettings->mThreadMode != kMode_Client ) {
+                fprintf( stderr, warn_invalid_server_option, option );
+                break;
+            }
+
+            mExtSettings->mListenPort = atoi( optarg );
+            break;
+
+        case 'M': // specify TCP MSS (maximum segment size)
+            Settings_GetUpperCaseArg(optarg,outarg);
+
+            mExtSettings->mMSS = byte_atoi( outarg );
+            break;
+
+        case 'N': // specify TCP nodelay option (disable Jacobson's Algorithm)
+            setNoDelay( mExtSettings );
+            break;
+
+        case 'P': // number of client threads
+#ifdef HAVE_THREAD
+            mExtSettings->mThreads = atoi( optarg );
+#else
+            if ( mExtSettings->mThreadMode != kMode_Server ) {
+                fprintf( stderr, warn_invalid_single_threaded, option );
+            } else {
+                mExtSettings->mThreads = atoi( optarg );
+            }
+#endif
+            break;
+
+        case 'R':
+            setRemoveService( mExtSettings );
+            break;
+
+        case 'S': // IP type-of-service
+            // TODO use a function that understands base-2
+            // the zero base here allows the user to specify
+            // "0x#" hex, "0#" octal, and "#" decimal numbers
+            mExtSettings->mTOS = strtol( optarg, NULL, 0 );
+            break;
+
+        case 'T': // time-to-live for multicast
+            mExtSettings->mTTL = atoi( optarg );
+            break;
+
+        case 'U': // single threaded UDP server
+            setSingleUDP( mExtSettings );
+            break;
+
+        case 'V': // IPv6 Domain
+            setIPV6( mExtSettings );
+            if ( mExtSettings->mThreadMode == kMode_Server 
+                 && mExtSettings->mLocalhost != NULL ) {
+                // Test for Multicast
+                iperf_sockaddr temp;
+                SockAddr_setHostname( mExtSettings->mLocalhost, &temp, 1);
+                if ( SockAddr_isMulticast( &temp ) ) {
+                    setMulticast( mExtSettings );
+                }
+            } else if ( mExtSettings->mThreadMode == kMode_Client ) {
+                // Test for Multicast
+                iperf_sockaddr temp;
+                SockAddr_setHostname( mExtSettings->mHost, &temp, 1 );
+                if ( SockAddr_isMulticast( &temp ) ) {
+                    setMulticast( mExtSettings );
+                }
+            }
+            break;
+
+        case 'W' :
+            setSuggestWin( mExtSettings );
+            fprintf( stderr, "The -W option is not available in this release\n");
+            break;
+
+        case 'Z':
+#ifdef TCP_CONGESTION
+	    setCongestionControl( mExtSettings );
+	    mExtSettings->mCongestion = new char[strlen(optarg)+1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, mExtSettings->mCongestion);
+	    strcpy( mExtSettings->mCongestion, optarg);
+#else
+            fprintf( stderr, "The -Z option is not available on this operating system\n");
+#endif
+	    break;
+
+        case 'A':
+#ifdef HAVE_SCHED_SETSCHEDULER
+            mExtSettings->mAffinity = strtol(optarg, &endptr, 0);
+            if (endptr == optarg ||
+                mExtSettings->mAffinity < 0 || mExtSettings->mAffinity > 1024) {
+                //i_errno = IEAFFINITY;
+                exit(-1);
+            }
+
+            comma = strchr(cparg, ',');
+            if (comma != NULL) {
+                mExtSettings->mAffinityEnd = atoi(comma+1);
+                if (mExtSettings->mAffinityEnd < 0 || mExtSettings->mAffinityEnd > 1024) {
+                    //i_errno = IEAFFINITY;
+                    exit(-1);
+                }
+                mExtSettings->mAffinityComma = 1;
+            } else {
+                comma = strchr(cparg, '-');
+                if (comma != NULL) {
+                    mExtSettings->mAffinityEnd = atoi(comma+1);
+                    if (mExtSettings->mAffinityEnd < 0 || mExtSettings->mAffinityEnd > 1024) {
+                        //i_errno = IEAFFINITY;
+                        exit(-1);
+                    }
+                    mExtSettings->mAffinityComma = 0;
+                }
+            }
+#else
+            printf("Don't have sched_setscheduler\n");
+            printf("CPU affinity is not support\n");
+            exit(-1);
+#endif
+        default: // ignore unknown
+            break;
+    }
+} // end Interpret
+
+void Settings_GetUpperCaseArg(const char *inarg, char *outarg) {
+
+    int len = strlen(inarg);
+    strcpy(outarg,inarg);
+
+    if ( (len > 0) && (inarg[len-1] >='a') 
+         && (inarg[len-1] <= 'z') )
+        outarg[len-1]= outarg[len-1]+'A'-'a';
+}
+
+void Settings_GetLowerCaseArg(const char *inarg, char *outarg) {
+
+    int len = strlen(inarg);
+    strcpy(outarg,inarg);
+
+    if ( (len > 0) && (inarg[len-1] >='A') 
+         && (inarg[len-1] <= 'Z') )
+        outarg[len-1]= outarg[len-1]-'A'+'a';
+}
+
+/*
+ * Settings_GenerateListenerSettings
+ * Called to generate the settings to be passed to the Listener
+ * instance that will handle dual testings from the client side
+ * this should only return an instance if it was called on 
+ * the thread_Settings instance generated from the command line 
+ * for client side execution 
+ */
+void Settings_GenerateListenerSettings( thread_Settings *client, thread_Settings **listener ) {
+    if ( !isCompat( client ) && 
+         (client->mMode == kTest_DualTest || client->mMode == kTest_TradeOff) ) {
+        *listener = new thread_Settings;
+        DEBUGP("%s[%d]: new Client: %p\n", __FILE__, (int)__LINE__, *listener);
+
+        memcpy(*listener, client, sizeof( thread_Settings ));
+        setCompat( (*listener) );
+        unsetDaemon( (*listener) );
+        if ( client->mListenPort != 0 ) {
+            (*listener)->mPort   = client->mListenPort;
+        } else {
+            (*listener)->mPort   = client->mPort;
+        }
+        (*listener)->mFileName   = NULL;
+        (*listener)->mHost       = NULL;
+        (*listener)->mLocalhost  = NULL;
+        (*listener)->mOutputFileName = NULL;
+        (*listener)->mMode       = kTest_Normal;
+        (*listener)->mThreadMode = kMode_Listener;
+
+        (*listener)->mHost = new char[strlen( client->mHost ) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*listener)->mHost);
+        strcpy( (*listener)->mHost, client->mHost );
+
+        (*listener)->mLocalhost = new char[strlen( client->mLocalhost ) + 1];
+        DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*listener)->mLocalhost);
+        strcpy( (*listener)->mLocalhost, client->mLocalhost );
+
+    } else {
+        *listener = NULL;
+    }
+}
+
+/*
+ * Settings_GenerateSpeakerSettings
+ * Called to generate the settings to be passed to the Speaker
+ * instance that will handle dual testings from the server side
+ * this should only return an instance if it was called on 
+ * the thread_Settings instance generated from the command line 
+ * for server side execution. This should be an inverse operation
+ * of GenerateClientHdr. 
+ */
+void Settings_GenerateClientSettings( thread_Settings *server, 
+                                      thread_Settings **client,
+                                      client_hdr *hdr ) {
+    int flags = ntohl(hdr->flags);
+    if ( (flags & HEADER_VERSION1) != 0 ) {
+        *client = new thread_Settings;
+        DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, *client);
+
+        memcpy(*client, server, sizeof( thread_Settings ));
+        setCompat( (*client) );
+        (*client)->mTID = thread_zeroid();
+        (*client)->mPort       = (unsigned short) ntohl(hdr->mPort);
+        (*client)->mThreads    = ntohl(hdr->numThreads);
+        if ( hdr->bufferlen != 0 ) {
+            (*client)->mBufLen = ntohl(hdr->bufferlen);
+        }
+        (*client)->mTCPWin = ntohl(hdr->mWindowSize);
+	if ( !isBWSet(server) ) {
+	    (*client)->mUDPRate = ntohl(hdr->mRate); 
+	    if ((flags & UNITS_PPS) == UNITS_PPS) {
+		(*client)->mUDPRateUnits = kRate_PPS;
+	    } else {
+		(*client)->mUDPRateUnits = kRate_BW;
+	    }
+	}
+	(*client)->mAmount     = ntohl(hdr->mAmount);
+        if ( ((*client)->mAmount & 0x80000000) > 0 ) {
+            setModeTime( (*client) );
+#ifndef WIN32
+            (*client)->mAmount |= 0xFFFFFFFF00000000LL;
+#else
+            (*client)->mAmount |= 0xFFFFFFFF00000000;
+#endif
+            (*client)->mAmount = -(*client)->mAmount;
+        }
+        (*client)->mFileName   = NULL;
+        (*client)->mHost       = NULL;
+        (*client)->mLocalhost  = NULL;
+        (*client)->mOutputFileName = NULL;
+        (*client)->mMode       = ((flags & RUN_NOW) == 0 ?
+                                   kTest_TradeOff : kTest_DualTest);
+        (*client)->mThreadMode = kMode_Client;
+        if ( server->mLocalhost != NULL ) {
+            (*client)->mLocalhost = new char[strlen( server->mLocalhost ) + 1];
+       	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*client)->mLocalhost);
+            strcpy( (*client)->mLocalhost, server->mLocalhost );
+        }
+        (*client)->mHost = new char[REPORT_ADDRLEN];
+   	    DEBUGP("%s[%d]: new char: %p\n", __FILE__, (int)__LINE__, (*client)->mHost);
+
+        if ( ((sockaddr*)&server->peer)->sa_family == AF_INET ) {
+            inet_ntop( AF_INET, &((sockaddr_in*)&server->peer)->sin_addr, 
+                       (*client)->mHost, REPORT_ADDRLEN);
+        }
+#ifdef HAVE_IPV6
+          else {
+            inet_ntop( AF_INET6, &((sockaddr_in6*)&server->peer)->sin6_addr, 
+                       (*client)->mHost, REPORT_ADDRLEN);
+        }
+#endif
+    } else {
+        *client = NULL;
+    }
+}
+
+/*
+ * Settings_GenerateClientHdr
+ * Called to generate the client header to be passed to the
+ * server that will handle dual testings from the server side
+ * This should be an inverse operation of GenerateSpeakerSettings
+ */
+void Settings_GenerateClientHdr( thread_Settings *client, client_hdr *hdr ) {
+    DEBUGP("client=%p, hdr=%p\n", client, hdr);
+
+    if ( client->mMode != kTest_Normal ) {
+        hdr->flags  = htonl(HEADER_VERSION1);
+    } else {
+        hdr->flags  = 0;
+    }
+    if ( isBuflenSet( client ) ) {
+        hdr->bufferlen = htonl(client->mBufLen);
+    } else {
+        hdr->bufferlen = 0;
+    }
+    hdr->mWindowSize  = htonl(client->mTCPWin);
+    hdr->mRate = htonl(client->mUDPRate);
+    if ( client->mListenPort != 0 ) {
+        hdr->mPort  = htonl(client->mListenPort);
+    } else {
+        hdr->mPort  = htonl(client->mPort);
+    }
+    hdr->numThreads = htonl(client->mThreads);
+    if ( isModeTime( client ) ) {
+        hdr->mAmount    = htonl(-(long)client->mAmount);
+    } else {
+        hdr->mAmount    = htonl((long)client->mAmount);
+        hdr->mAmount &= htonl( 0x7FFFFFFF );
+    }
+    if (client->mUDPRateUnits == kRate_PPS)
+	hdr->flags |= htonl(UNITS_PPS);
+    if ( client->mMode == kTest_DualTest )
+	hdr->flags |= htonl(RUN_NOW);
+}
diff -uprN iperf-2.0.9.orig/src/main.cpp iperf-2.0.9/src/main.cpp
--- iperf-2.0.9.orig/src/main.cpp	2016-06-07 03:48:21.000000000 +0900
+++ iperf-2.0.9/src/main.cpp	2017-02-11 02:06:37.198429133 +0900
@@ -75,6 +75,12 @@
 #include "service.h"
 #endif 
 
+#ifdef _DEBUG
+#define DEBUGP(fmt, ...)    printf(fmt, ## __VA_ARGS__)
+#else
+#define DEBUGP(fmt, ...)
+#endif
+
 /* -------------------------------------------------------------------
  * prototypes
  * ------------------------------------------------------------------- */
@@ -158,6 +164,7 @@ int main( int argc, char **argv ) {
 
     // Allocate the "global" settings
     thread_Settings* ext_gSettings = new thread_Settings;
+    DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, ext_gSettings);
 
     // Initialize settings to defaults
     Settings_Initialize( ext_gSettings );
@@ -207,6 +214,7 @@ int main( int argc, char **argv ) {
             thread_Settings *into = NULL;
             // Create the settings structure for the reporter thread
             Settings_Copy( ext_gSettings, &into );
+            DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, into);
             into->mThreadMode = kMode_Reporter;
 
             // Have the reporter launch the client or listener
@@ -256,6 +264,7 @@ int main( int argc, char **argv ) {
  * ------------------------------------------------------------------- */
 
 void Sig_Interupt( int inSigno ) {
+    DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
 #ifdef HAVE_THREAD
     // We try to not allow a single interrupt handled by multiple threads
     // to completely kill the app so we save off the first thread ID
@@ -288,15 +297,18 @@ void Sig_Interupt( int inSigno ) {
  * ------------------------------------------------------------------- */
 
 void cleanup( void ) {
+    DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
 #ifdef WIN32
     // Shutdown Winsock
     WSACleanup();
 #endif
     // clean up the list of clients
     Iperf_destroy ( &clients );
+    DEBUGP("%s[%d]: Iperf_destroy: %p\n", __FILE__, (int)__LINE__, clients);
 
     // shutdown the thread subsystem
     thread_destroy( );
+    DEBUGP("%s[%d]: thread_destroy\n", __FILE__, (int)__LINE__);
 } // end cleanup
 
 #ifdef WIN32
@@ -308,7 +320,7 @@ void cleanup( void ) {
  * 
  *-------------------------------------------------------------------- */
 VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv) {
-    thread_Settings* ext_gSettings;
+    thread_Settings* ext_gSettings = NULL;
  
     // report the status to the service control manager.
     //
@@ -319,6 +331,7 @@ VOID ServiceStart (DWORD dwArgc, LPTSTR
         goto clean;
 
     ext_gSettings = new thread_Settings;
+    DEBUGP("%s[%d]: new thread_Settings: %p\n", __FILE__, (int)__LINE__, ext_gSettings);
 
     // Initialize settings to defaults
     Settings_Initialize( ext_gSettings );
@@ -362,6 +375,8 @@ VOID ServiceStart (DWORD dwArgc, LPTSTR
         thread_Settings *into = NULL;
 #ifdef HAVE_THREAD
         Settings_Copy( ext_gSettings, &into );
+        DEBUGP("%s[%d]: Settings_Copy: %p\n", __FILE__, (int)__LINE__, into);
+
         into->mThreadMode = kMode_Reporter;
         into->runNow = ext_gSettings;
 #else
@@ -369,7 +384,17 @@ VOID ServiceStart (DWORD dwArgc, LPTSTR
 #endif
         thread_start( into );
     }
-    
+
+    if ((ext_gSettinfs != NULL) && (ext_gSettinfs->multihdr != NULL)) {
+        DEBUGP("%s[%d]: free: %p\n", __FILE__, (int)__LINE__, ext_gSettinfs->multihdr);
+        free(ext_gSettinfs->multihdr);
+        ext_gSettinfs->multihdr = NULL;
+    }
+    if ((ext_gSettinfs != NULL) {
+        DEBUGP("%s[%d]: delete: %p\n", __FILE__, (int)__LINE__, ext_gSettinfs);
+        delete(ext_gSettinfs);
+        ext_gSettinfs = NULL;
+    }
     // report the status to the service control manager.
     //
     if ( !ReportStatusToSCMgr(
@@ -404,6 +429,7 @@ VOID ServiceStart (DWORD dwArgc, LPTSTR
 //    the service has stopped responding.
 //    
 VOID ServiceStop() {
+    DEBUGP("%s[%d]\n", __FILE__, (int)__LINE__);
 #ifdef HAVE_THREAD
     Sig_Interupt( 1 );
 #else
